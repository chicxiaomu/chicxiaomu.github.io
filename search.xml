<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android性能优化（三）之读书笔记]]></title>
      <url>%2F2017%2F04%2F23%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Android性能优化主要几个方面: 布局优化 绘制优化 内存泄漏优化 响应速度优化 ListView, Bitmap, 线程优化 ##布局优化布局优化的思想就是尽量较少布局文件的层级,这就可以让Android绘制时的工作量减少 删除无用的控件和层级, 有选择地使用ViewGroup. 例如RelativeLayout和LinearLayout. 都可以的话那么就采用LinearLayout. 因为RelativeLayout的功能比较复杂, 它的布局过程需要花费更多的CPU时间. FrameLayout和LinearLayout都是一种简单高效的ViewGroup. 如果需要嵌套才可以实现的布局那么就是用RelativeLayout. 布局优化的另外一个方法就是采用标签, 标签和ViewStub. include主要用于布局的重用 merge一般和include标签配合使用, 它可以减少布局的层级 ViewStub: 提供了按需加载的功能, 当需要时才会将ViewStub中的布局加载到内存,这可以提高程序的初始化. include标签 可以将一个指定的布局文件加载到当前布局文件中: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;include android:id=&quot;@+id/hah&quot; android:layout=&quot;@layout/layout_titlebar&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; android:visibility=&quot;invisible&quot;/&gt; &lt;/LinearLayout&gt; 这个标签里面支持的属性很少, 根据编辑器的提示只有5个, 而且width和height如果要出现需要同时出现, 也可以不写, 最重要的就是一个必须指定导入的布局layout=”xxxxxx”. merge 这个标签一般和include标签一起使用从而减少布局的层级. 有时候会有这样一个场景, 如果include导入的布局的根布局是竖直方向的, 而当前布局也是竖直方向的, 那么和显然有一个层级是多余的. 这个时候使用就可以去掉重复布局. ViewStub ViewStub继承了View, 这是一个非常轻量级的且宽高都是0, 因此它本身不参与任何的布局和绘制过程. 而ViewStub存在的意义在于按需加载所需的布局文件, 在实际开发中, 有很多布局文件在正常情况系不会显示, 如网络异常等. 这个时候就没有必要再整个界面初始化的时候将其加载. 首先布局中添加 &lt;ViewStub android:id=&quot;@+id/stub_import&quot; android:inflatedId=&quot;@+id/stin_root&quot; android:layout=&quot;@layout/layout_stubview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot;/&gt; 这里android:layout属性还是导入外部布局的意思. inflatedId这个添加的id的属性是给导入进来的布局layout_stubview的根布局设定了一个id值. 然后在代码中有两种方式让其显示 // 方式一 通过设置visibility ((ViewStub)findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); // 方式二 通过inflate加载显示 //View inflate = ((ViewStub) findViewById(R.id.stub_import)).inflate(); // 通过inflatedId这个id可以得到加载进来的布局的根布局 LinearLayout commLv = (LinearLayout) findViewById(R.id.stin_root); ##绘制优化 绘制优化是指View#onDraw()方法要避免执行大量的操作.两个方面 onDraw中不要创建新的局部对象, 因为onDraw()方法可能会被频繁调用, 这样就会在一瞬间产生大量的临时对象, 这不仅占用了过多的内存而且还会导致系统频繁的gc, 降低了程序的执行效率. 不要做耗时任务, 也不能执行成千上万次的循环操作. 即使每次循环都很轻量级, 但是大量的循环仍然十分抢占CPU的时间片, 这会造成View的绘制流程不流畅. 按照官方的规范, View的绘制帧率保证60fps最佳. 也就是16ms的为每一阵帧的绘制时间. ##内存泄漏优化 ###情况1. 静态变量导致的内存泄漏 private static View sView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sView = new View(this); } 如非必须传递Activity的引用不要这么做, 如果需要上下文可以传递getApplicationContext()返回的上下文 ###情况2. 单例模式导致的内存泄漏 常见的就是在使用注册监听的时候, 往往会往一个单例类中传入this本类对象,进行注册, 然后却没有解注册的动作. 那么这个Activity被引用的时间也就是和Application的生命周期持平. ###情况3. 属性动画导致的内存泄漏 在Android 3.0中加入了属性动画, 属性动画有一类无限循环的动画, 如果在Activity中播放此类动画且没有在Activity退出的时候没有停止动画. 尽管无法界面上看到效果, 但是创建这个动画所关联的View被动画所持有, 而View又持有了Activity, 最终Activity无法释放. 解决方案, 就是在onDestroy()中调用动画的cancel()来停止动画. ##响应速度和ANR日志分析响应速度的优化核心就是避免主线程做耗时操作, 响应速度过慢更多体现在Activity启动的速度上. 如果主线程内做太多的事情, 会导致Activity启动时出现黑屏现象, 甚至出现ANR. Android中规定如果Activity5秒钟之内无法响应屏幕事件或者键盘输入事件就会出现ANR. 而BroadCastReceiver如果10秒之内还未执行完操作也会出现ANR. 如果进程发生了ANR以后, 系统会在data/anr目录下创建一个文件traces.txt. 通过分析这个文件就定位出原因.(这个文件很长如果需要分析, 请先删除文件生成一个在分析来进行了解) 通过一个例子来了解如何去分析文件, 首先在onCreate()添加如下代码, 让主线程等待一个锁,然后点击返回5秒后会出现ANR, 贴代码 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 以下代码是为了模拟一个ANR的场景来分析日志 new Thread(new Runnable() { @Override public void run() { testANR(); } }).start(); SystemClock.sleep(10); initView(); } /** * 以下两个方法用来模拟出一个稍微不好发现的ANR */ private synchronized void testANR(){ SystemClock.sleep(3000 * 1000); } private synchronized void initView(){} 这样会出现ANR, 然后导出/data/anr/straces.txt文件. 因为内容比较多只贴出关键部分 DALVIK THREADS (15): &quot;main&quot; prio=5 tid=1 Blocked | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x73db0970 self=0xf4306800 | sysTid=19949 nice=0 cgrp=apps sched=0/0 handle=0xf778d160 | state=S schedstat=( 151056979 25055334 199 ) utm=5 stm=9 core=1 HZ=100 | stack=0xff5b2000-0xff5b4000 stackSize=8MB | held mutexes= at com.szysky.note.androiddevseek_15.MainActivity.initView(MainActivity.java:0) - waiting to lock &lt;0x2fbcb3de&gt; (a com.szysky.note.androiddevseek_15.MainActivity) - held by thread 15 at com.szysky.note.androiddevseek_15.MainActivity.onCreate(MainActivity.java:42) 这段可以看出最后指明了ANR发生的位置在ManiActivity的42行. 并且通过上面看出initView方法正在等待一个锁锁的类型是一个MainActivity对象. 并且这个锁已经被线程id为15(tid=15)的线程持有了. 接下来找一下线程15 &quot;Thread-404&quot; prio=5 tid=15 Sleeping | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c00f80 self=0xeb95bc00 | sysTid=19985 nice=0 cgrp=apps sched=0/0 handle=0xef34be80 | state=S schedstat=( 391248 0 1 ) utm=0 stm=0 core=2 HZ=100 | stack=0xe2bfe000-0xe2c00000 stackSize=1036KB | held mutexes= at java.lang.Thread.sleep!(Native method) - sleeping on &lt;0x2e3896a7&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1031) - locked &lt;0x2e3896a7&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:985) at android.os.SystemClock.sleep(SystemClock.java:120) at com.szysky.note.androiddevseek_15.MainActivity.testANR(MainActivity.java:50) - locked &lt;0x2fbcb3de&gt; (a com.szysky.note.androiddevseek_15.MainActivity) - tid = 15 就是相关信息如上, 首行已经标出线程的状态为Sleeping, 原因在50行, 就是SystemClock.sleep(3000 * 1000);这句话. 也就是testANR(). 而最后一行也表明了持有的locked&lt;0x2fbcb3de&gt;就是主线程在等待的那个锁对象. ##ListView和Bitmap优化 ListView: 在前面已经说过了, 主要三个方面: 采用ViewHolder避免在getView中执行耗时操作; 其次要根据列表的滑动状态来控制任务的执行频率; 最后可以尝试开启硬件加速是ListView滑动更加流畅. ListView的优化策略也完全适用于GridView Bitmap: 也已经说过, 主要是通过BitmapFactory.Options根据需要对图片进行采样, 采样率的设置通过inSampleSize属性. ##线程优化 主要思想就是采用线程池, 避免程序中存在大量的Thread. 线程池可以重用内部的线程, 避免了线程创建和销毁的性能开销. 同时线程池还能有效的控制线程的最大并发数, 避免了大量线程因互相巷战系统资源从而导致阻塞现象的发生. ##额外的性能优化建议 避免创建过多的对象 不要过多使用枚举, 枚举占用的内存空间比整形还要大,使用Android官方提供的方法可参考另一篇博客链接跳转 常量请使用 static final 来修饰 使用一些Android特有的数据结构, 比如SparseArray和Pair等 适当的使用软引用和弱引用 采用内存缓存和磁盘缓存 尽量采用静态内部类, 避免潜在的由于内部类而导致的内存泄漏 ##内存泄漏分析工具MATMAT全程Eclipse Memory Analyzer, 是一个内存泄漏分析工具. 下载后解压即可. 下载地址http://www.eclipse.org/mat/downloads.php. 这里仅简单说一下. 这个我没有手动去实践, 就当个记录, 因为现在Android Studio可以直接分析hprof文件. 可以手动写一个会造成内存泄漏的代码, 然后打开DDMS, 然后选中要分析的进程, 然后单击Dump HPROF file这个按钮. 等一小段会生成一个文件. 这个文件不能被MAT直接识别. 需要使用Android SDK中的工具进行格式转换一下.这个工具在platform-conv文件夹下 hprof-conv 要转换的文件名 输出的文件名 文件名的签名有包名. 然后打开MAT通过菜单打开转换后的这个文件. 这里常用的就有两个 Histogram: 可以直观的看出内存中不同类型的buffer的数量和占用内存大小 Dominator Tree: 把内存中的对象按照从大到小的顺序进行排序, 并且可以分析对象之间的引用关系, 内 存泄漏分析就是通过这个完成的.分析内存泄漏的时候需要分析Dominator Tree里面的内存信息, 一般会不直接显示出来, 可以按照从大到小的顺序去排查一遍. 如果发生了了泄漏, 那么在泄漏对象处右键单击Path To GC Roots-&gt;exclude wake/soft references. 可以看到最终是什么对象导致的无法释放. 刚才的操作之所以排除软引用和弱引用是因为,大部分情况下这两种类型都可以被gc回收掉,所以基本也就不会造成内存泄漏. 同样这里也可以使用搜索功能, 假如我们手动模拟了内存泄漏, 泄漏的对象就是Activity那么我们back退出重进循环几次, 会发现其实很多个Activit对象. 更多的东西我也不会,作者也没有说.. 不过这些以后Android Studio都会很有好用对应功能. ##提高程序的可维护性这里主要说Android的程序设计思想. 主旨是如何提高代码的可维护性和可扩展性, 而程序的可维护性也包含可扩展性. 这里的切入点为: 代码风格, 代码的层次性和单一职责原则, 面向扩展编程以及设计模式 可读性是代码可维护性的前提, 一段只能让机器读懂的代码即使可以跑也属于”坏味道的代码”, 而良好的代码风格在一定程度上可以提高从程序的可读性. 代码的风格有 命名规范, 代码排版, 注释说明. 命名要规范, 正确传达出变量或者方法的定义, 少用缩写除非业界通用的缩写如String-&gt;str.能让人一眼明白的. 私有成员要以m开头. 静态成员要以s开头. 常量要全部大写. 代码排版上留出合理的空白来区分不同的代码块, 其中同类变量的声明放在一组, 两类变量之间留出一行作为空白. 仅为非常关键的代码添加注释, 其他地方不写注释, 这就对变量和方法的命名风格提出了很高的要求. 一个合理的命名风格可以让读者阅读源码的时候就如阅读注释一样. 因此根本不需要为代码额外写注释 代码的层次是指代码要有分层的概念, 对于一段业务逻辑, 不要试图在一个方法或者一个类中去全部实现, 而是将其分成几个子逻辑, 然后每个逻辑做自己的事情, 这样即显得代码层次分明, 又可以分解任务从而实现简单逻辑的效果. 单一职责是和层次性相关联的. 代码分层以后, 每一层仅仅关注少量的逻辑, 这样就做到了单一职责. 程序的扩展性, 由于很多时候在开发过程中无法保证已经做好的需求不在后面的版本发生更改, 因此在写程序的时候要时刻考虑到扩展的问题, 考虑如果这个逻辑以后发生了改变那么哪些需要修改, 以及怎样在以后修改的时候降低工作量, 而面向扩展编程可以让程序具有很好的扩展性. 适当使用设计模式可以提高代码的可维护性和可扩展性. 但是一定控制设计的度, 千万别过度设计.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化（二）之Monkey性能测试]]></title>
      <url>%2F2017%2F04%2F15%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8BMonkey%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[##一、Monkey简介 Android的SDK 里面，Monkey的tools是一个命令行工具，当连接Android设备时，只要在命令行里输入相应命令就能运行tools； Monkey test是一项压力测试，可以在规定的次数范围内做任何随机的操作，随机操作包括点击、滑动、Application切换、横竖屏、应用关闭等等，用户能做的操作统统可以模拟； Monkey test跑出来crash的bug等级永远为1，版本release前，Monkey跑出的结果中crash要为0。业内标准：final release前，Monkey跑完的总次数应为25W次，其结果里不允许有nullPointException出现. ##二、Monkey命令 标准命令： abd devices 列出所有的已连接的设备（包括真机和虚拟机） adb shell 进入shell模式，查看data/data文件夹中的安装包情况 [adb shell] monkey [options] 栗子：adb shell monkey -v 500 产生500次随机事件，作用与系统中所有的activity（其实也不是所有的activity，而是包含 Intent.CATEGORY_LAUNCHER 或Intent.CATEGORY_MONKEY 的activity）。 ##三、命令分类 常用选项： -help：打印帮助信息-v：指定打印信息的详细级别，一个 -v增加一个级别 ， 默认级别为 0 ,最高为-v -v -v 事件选项； -s：指定产生随机事件种子值，相同的种子值产生相同的事件序列。如： -s 200 --throttle：每个事件结束后的间隔时间——降低系统的压力（如不指定，系统会尽快的发送事件序列）。如：--throttle 100 --pct-touch：指定触摸事件的百分比，如：--pct-touch 5% 相关的还有以下option： --pct-motion &lt;percent&gt; （滑动事件） --pct-trackball &lt;percent&gt; （轨迹球事件） --pct-nav &lt;percent&gt;（导航事件 up/down/left/right） --pct-majornav &lt;percent&gt; (主要导航事件 back key 、 menu key) --pct-syskeys &lt;percent&gt; (系统按键事件 Home 、Back 、startCall 、 endCall 、 volumeControl) --pct-appswitch &lt;percent&gt; （activity之间的切换） --pct-anyevent &lt;percent&gt;（任意事件） 约束选项： -p：指定有效的package（如不指定，则对系统中所有package有效），一个-p 对应一个有效package， 如： -p com.ckt -p com.ckt.asura； -c：activity必须至少包含一个指定的category，才能被启动，否则启动不了； 调试选项： –dbg-no-events：初始化启动的activity，但是不产生任何事件。为了得到最佳结果，把它与-v、一个或几个包约 束、以及一个保持Monkey运行30秒或更长时间的非零值联合起来，从而提供一个环境，可以监视应用程序所调用的包之间的转换 --hprof：指定该项后在事件序列发送前后会立即生成分析报告 —— 一般建议指定该项。 --ignore-crashes：忽略崩溃 --ignore-timeouts：忽略超时 --ignore-security-exceptions：忽略安全异常 --kill-process-after-error：发生错误后直接杀掉进程 --monitor-native-crashes：跟踪本地方法的崩溃问题 --wait-dbg：直到连接了调试器才执行monkey测试。 ##四、栗子： adb shell monkey -p com.ssjjsy.sdk.hk.demo -s 100 --throttle 10 --ignore-crashes --ignore-timeouts --monitor-native-crashes --pct-appswitch 30 --pct-majornav 20 --pct-nav 20 --pct-touch 20 --pct-motion 10 -v -v -v 10000 &gt; E:\Git\monkey_log.txt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化（一）之常用工具]]></title>
      <url>%2F2017%2F04%2F09%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[Android性能优化相关的开发工具有很多很多种，这里对如下六个工具做个简单的使用介绍，主要有： Android开发者选项 分析具体耗时的Trace view 布局复杂度工具Hierarchy View 应用启动时间 Memory、CPU、Network分析 静态代码检查工具Lint 程序稳定性monkey ###一、Android开发者选项 Andorid手机自带的开发者选项： Take bug report（进行漏洞报告）: 点击这个选项会获取当前设备的log信息文件，打包并准备发送我们想要发送的人。这会花费1、2分钟，然后会看到一个准备好的提示信息，然后可以点击发送。 Desktop backup password（桌面备份密码）：可以使用adb备份和存储app和他们的关联数据到你的电脑。这个选项强制需要一个密码备份和存储。 Stay awake（保持唤醒）：选中这个复选框会强制屏幕唤醒，只要连接上usb线或者充电的时候都会不进入休眠，当需要调试的时候不用老是去解锁了，相当方便。 Select runtime（选择运行时）：你可以选择Dalvik或者ART。ART仍然是实验性的，直到Android L才最终release。 Enable Bluetooth HCI snoop log（蓝牙HCI搜索日志）：有时，开发者需要获取和分析蓝牙的HCI包，使能这个会在设备storage（路径为：/sdcard/btsnoop_hco.log）中保存包的信息。接着你可以使用类似wireshark等软件分析。 Process stats（程序状态）：你需要知道的所有运行在手机上的程序的任何信息。包括了ram使用量，运行时间等。 USB debugging（USB调试）：USB调试时使用，使用DDMS和ADB命令的时候也需要这个使能，不勾选这个就不能调试我们的应用了。 Revoke USB debugging authorizations（撤回USB除错授权）：当第一次USB线连接电脑的时候，需要认证并且建立密钥，这个操作删除这个认证，强制重新来一遍。 Power menu bug reports（电源菜单中包括漏洞报告）：在电源菜单中包括用于进行漏洞报告的选项。 Allow mock locations（允许虚拟位置）：允许手动写入位置信息，对于需要模拟位置的应用来说十分方便，可以干一些坏事，你懂得。 Select debug app（选择待调试的应用程序）：这个设置让你选择一个待调试的应用。 Wait for debugger（等待调试程序）：等待调试程序 Show touches（显示触摸位置）：显示触摸的位置，一般是一个小圈圈。 Pointer location（显示指针位置）：显示出当前位置的坐标。 Show surface updates（显示屏幕更新）：屏幕更新时会闪烁。 Show layout bounds（显示布局边界）：显示剪切边界、边缘。 Force RTL layout direction（强制RTL布局）：界面布局从右至左。 Window animation scale（窗口动画比例）：窗口动画的比例，数字越小，速度越快。 Transition animation scale（过渡动画比例）：过渡动画的比例，同上。 Simulate secondary displays（模拟二级显示）：允许开发者模拟不同尺寸的表现。 Force GPU rendering（强制GPU渲染）：强制应用使用硬件2D渲染除非应用本身不需要。 Show GPU view updates（显示GPU视图更新）：任何用硬件GPU来绘制视图的会有红色的覆盖层。 Show hardware layer updates（显示硬件层更新）：这个设置会告诉你什么时候硬件层在更新。 Debug GPU overdraw（调试GPU过度渲染）：过度渲染发生在任何时候当应用请求系统绘制一些视图在其他视图之上的时候。 Force 4x MSAA（启动4x MSAA）：这个设置强制多重采样抗锯齿。MSAA就是寻找出物体边缘部分的像素，然后再把画缩放到当前的显示器上。会降低性能提升视觉的美感。 Strict mode enabled（严格模式）：应用程序在主线程上执行长时间操作屏幕会闪烁。 Show CPU usage（显示CPU使用情况）：在屏幕右上角显示当前CPU的信息。 Profile GPU rendering（GPU显示配置文件）：这个设置可以在屏幕上显示也可以写入到文件中。 Enable OpenGL traces（启动OpenGL跟踪）：这个设置是观察OpenGL的错误，并把log保存到文件中。 Don’t keep activities（不保留活动）：用户离开后立即清理每个活动。 Background process limit（限制后台进程）：允许当前后台运行多少个进程的一个选择。 Show all ANRs（显示全部ANR）：当应用有bug的时候回显示应用无响应对话框。 ###二、应用具体耗时工具Trace view Trace view用于查找程序运行时具体耗时在哪，它显示两个面板，一个是Timeline面板，描述每一个线程和方法启动和结束的时间。另一个是Profile面板，提供一个所有方法内部发生了什么的概要。 先新建工程PerformanceTool，然后新建布局main_activity_layout.xml，一个按钮用来加载一个网页；另一个页面就是一个webview。然后编写代码，首先是MainActivity.java: public class MainActivity extends AppCompatActivity { private Button mBtnOpenWevView = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); } private void initView() { mBtnOpenWevView = (Button) findViewById(R.id.button); mBtnOpenWevView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this , WebViewActivity.class); startActivity(intent); } }); } } 接着是WebviewActivity.java： public class WebViewActivity extends AppCompatActivity { private WebView mWebView = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_webview); //Debug.startMethodTracing(&quot;perform&quot;); initView(); //Debug.stopMethodTracing(); } private void initView() { mWebView = (WebView) findViewById(R.id.mWebView); mWebView.loadUrl(&quot;http://www.baidu.com&quot;); mWebView.setWebViewClient(new WebViewClient(){ @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { view.loadUrl(url); return true; } }); } @Override protected void onDestroy() { super.onDestroy(); mWebView = null; } } ####view形式 traceview有两种使用方法，一种是直接通过DDMS工具来start和stop trace，使用方法如下：接着运行程序，成功运行后 点击菜单栏的Tools -&gt; Android -&gt; Android Device Monitor ： 进入Monitor之后，点击DDMS,这个时候在monitor的左边面板会出现当前设备上的包名列表 点击对应要trace的包名，然后点击Stop左边的有个小红点的按钮点击ok之后便开始执行trace了，这个时候再点击那个app里面的加载网页的按钮，加载完后，再次点击那个STOP左边那个变成小黑点的按钮。 接着便trace完成了，就可以查看如下两个面板了。上图就是Timeline面板，左边就是每行都是显示一个线程，右边对应它的时间线。可以看出来主要就是main线程在做事情。上图就是Profile面板，首先是左边的name，比如序号为14，这里展开有Parents和Children，其中Parents就是调用该方法的方法，这里onCreate在performCreate中被调用，Children就是该方法内部调用的方法，这里调用了loadUrl。与项目中的真实的代码完全相符。接着看下右边一排的Incl Cpu Time、Excl Cpu Time、Incl Real Time、Excl Real Time、Call+Recur Calls/Total、Cpu Time/Call、Real Time/Call。 Incl Cpu Time：某方法占用CPU的时间，包含内部调用其他方法占用CPU的时间。 Excl Cpu Time：某方法占用CPU的时间，不包含内部调用其他方法所占用的CPU时间。 Incl Real Time：某方法运行的真实的时间（单位ms），包含内部调用其他方法所占用的真实时间。 Excl Real Time：某方法运行的真实的时间（单位ms），不包含内部调用其他方法所占用的真实时间。 Call+Recur Calls/Total：某方法被调用的次数以及递归调用占总调用次数的百分比。 Cpu Time/Call：某方法占用CPU的时间和次数的比例。 Cpu Time/Call：某方法占用CPI真实时间和调用次数的比例。 ####代码形式 另一种是通过注入代码来实现： 在WebviewActivity的onCreate代码中加入两行代码如下： @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_webview); Debug.startMethodTracing(&quot;perform&quot;); initView(); Debug.stopMethodTracing(); } 别忘了加上SD卡的读写权限，然后运行app，点击加载网页按钮，就会在/sdcard目录下生产perform.trace文件，通过adb pull可以把文件导出来。 adb pull /sdcard/perform.trace Downloads/ 这里导出到了Downloads目录下，然后通过AndroidMonitor的file-&gt;open file选择这个文件打开：然后就可以查看分析了。通过代码的好处就是比较精确的得到我们想要测试的，不过代价就是要写代码编译，导出来，步骤相对来说比较繁琐。而直接使用工具的话只是一个大概的范围，但是方便快捷。可以视情况使用其中之一。 ###三、布局复杂度工具Hierarchy View Hierarchy View主要是检测布局复杂度，各视图的布局耗时情况的一个工具，它需要在模拟器上进行，真机好像也有方法解决，不过很懒没去折腾，主要还是学习工具为主嘛。 点击菜单Tools -&gt; Android -&gt; Android Device Monitor： 然后进入到Android Device Monitor，选中Hierarchy View选中后会出现层级树然后我们点击那个加载网页的button，可以看到对应的加载耗时，分别有Measure，Layout和Draw的耗时。 我们可以根据其耗时来优化我们界面。 ###四、应用启动时间 一般我们都会比较关注一个app启动的时间，如果启动太慢了，用户可能就不想玩了，这里有个方法可以测试应用启动的时间：命令行如下： adb shell am start -W packagename/activity 这里举个例子，比如说是上述项目中的PerformaceDemo app，那么首先打开终端，连接上usb线，然后终端输入: adb shell am start -W com.performance.demo/.MainActivity 等待会儿，app会启动，并且输出如下所示信息： Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER]cmp=com.performance.demo/.MainActivity } Status: ok Activity: com.performance.demo/.MainActivity ThisTime: 791 TotalTime: 791 WaitTime: 808 Complete 如上所示可以看出用时791ms。 ###五、Memory、CPU、Network 很多时候我们需要了解app的内存使用情况，CPU占用怎样，网络速度如何。为了提高性能，我们总是想把内存减少到最小，CPU占用率近可能小，网络情况适宜。当然这些可以用命令行实现，毕竟androd基于linux操作系统的，但是那样显得很麻烦又不是很直观，很庆幸Android Studio自带了功能。Android Studio的Android Monitor里面有logcat和Monitors，选中monitors就有对于Memory，CPU和Network的展示。如下图所示： 这里展示了Memory的使用量，CPU的占用量，以及网络的速度。上图就是点击了加载网页时候的一个分布情况。它可以帮我们查看并优化我们的程序，从而显得非常的直观。 ###六、 静态代码检查工具Lint Lint主要是提供一套静态代码分析的工具，它可以帮助我们检查项目中存在的问题，让我们更有规范性的开发App。运行菜单的analyze-&gt;Inspect Code 稍息片刻系统就会分析完成，如下所示： Lint分很多子项。Internationalization国际化问题，硬编码的文字都是需要添加进@string资源，Security安全性问题，Usability可用性问题，未使用到资源、资源缺少的问题等等，具体可以根据分析后的结果来一步步改善。 ###七、程序稳定性：monkey 通过monkey对程序在提交测试前做自测，可以检测出明显的导致程序不稳定的问题，执行monkey只需要一行命令，提交测试前跑一次可以避免应用刚提交就被打回的问题。 adb shell monkey -p com.performance.demo -v 500 -p表示包名，-v表示反馈级别 500就是500个伪随机事件若在压力测试中程序崩溃或者接收到任何失控异常，就会自动停止。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java服务端开发环境搭建]]></title>
      <url>%2F2017%2F03%2F21%2FJava%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[0 JDK下载安装 进入源码存放目录（eg：cd /data/src） wget下载jdk，由于wget不支持重定向，所以需要添加header（eg:wget –no-cookie –header “Cookie: oraclelicense=accept-securebackup-cookie” jdk） mv 下载的jdk压缩包到 安装目录（eg：mv jdk.tar.gz /usr/local/java） 解压安装包(eg:tar zxvf jdk.tar.gz) 运行 java -version 验证是否安装成功 1 配置环境变量这里介绍两种常用的环境变量配置方法： 修改/etc/profile文件:如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。 打开环境变量配置文件（eg:vi /etc/profile） 在文件尾追加 JAVA_HOME=/usr/local/java/jdk1.8.0_121 CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME export CLASSPATH 使用source命令启用配置（eg:source /etc/profile） 修改.bashrc文件：这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别。 打开用户目录的.bashrc文件（eg:vi ~/.bashrc） 在文件尾追加 JAVA_HOME=/usr/local/java/jdk1.8.0_121 CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME export CLASSPATH 退出重新登录 2 环境测试 在任意目录，通常在/data/tmp目录新建一个java文件（eg:Demo.java） 编译代码，javac Demo.java 运行代码，java Demo 3 常见问题“Error: Could not find or load main class” 如果java代码里面没有设置package，则是环境变量配置有误； 如果java代码里面有设置package，则需要构建和包名一致的路径，eg:package com.cjh.demo,则需要构建com/cjh/demo目录，并把编译的class文件放到该目录，然后回到和com平级的目录里面运行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我和我的博客]]></title>
      <url>%2F2017%2F03%2F03%2F%E6%88%91%E5%92%8C%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[工作已经快两年了，写了很多代码，也看了很多博客，慢慢的也有了自己的感悟，所以就有了这个博客。 GitHub. 缘由我认为有两点 记录与升华。通过写博客，我们可以记录工作中的思考、生活中的点滴，技术成长的同时，也装点了我们的回忆。 分享与提升。通过写博客，促使我们去专研问题并与人分享，同时通过他人的交流反馈来改善自我、提升自我。 另一份简历。博客也是简历之一，通过博客，可以更好的向他人展示自我。这也是非常有趣的事O(∩_∩)O~~ 风格简单，直接，文艺]]></content>
    </entry>

    
  
  
</search>
