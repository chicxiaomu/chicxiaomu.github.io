<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android多线程实现方式]]></title>
      <url>%2F2017%2F06%2F15%2FAndroid%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[一、前言Android中线程分为主线程（UI线程）和子线程，主线程主要处理和界面相关的事情，而子线程则用于执行耗时操作。如果在主线程中执行耗时操作，比如网络请求操作，则会报NetworkOnMainThreadException；如果是其他耗时操作，界面卡顿时间超过5秒则会导致程序无法及时响应（ANR）。因此耗时操作必须在子线程去执行。Android提供了五种常用的线程实现方式，分别是： Thread AsyncTask HandlerThread IntentService ThreadPoolExecutor 二、线程使用Threadnew Thread(){ @Override public void run() { super.run(); // NetWork or DataBase Operation } }.start(); 这是最简单的创建异步线程的姿势了，但是每当项目中出现这类代码，我都忍不了要把它改掉的冲动。 缺点： 创建及销毁线程消耗性能较大； 缺乏统一的管理； 优先级与UI线程一致，抢占资源处于同一起跑线； 匿名内部类默认持有外部类的引用，有内存泄漏的风险; 需要自己处理线程切换。备注：此种姿势最好不要使用，特定场景下（例如App启动阶段为避免在主线程创建线程池的资源消耗）使用的话务必加上优先级的设置。 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); AysncTaskAsyncTask是Android1.5提供了工具类，它使创建异步任务变得更加简单，同时屏蔽了线程切换。 下面代码是官方文档的示例代码，在doInBackground()方法中处理耗时操作，处理的进度由onProgressUpdate()方法进行回调，耗时操作处理完成之后会调用onPostExecute()方法，在UI线程中执行。 private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; { protected Long doInBackground(URL... urls) { int count = urls.length; long totalSize = 0; for (int i = 0; i &lt; count; i++) { totalSize += Downloader.downloadFile(urls[i]); publishProgress((int) ((i / (float) count) * 100)); // Escape early if cancel() is called if (isCancelled()) break; } return totalSize; } protected void onProgressUpdate(Integer... progress) { setProgressPercent(progress[0]); } protected void onPostExecute(Long result) { showDialog(&quot;Downloaded &quot; + result + &quot; bytes&quot;); } } 优点： 创建异步任务变得更加简单，同时屏蔽了线程切换； 在AsyncTask.java中我们可以看到，异步线程的优先级已经被默认设置成了：THREAD_PRIORITY_BACKGROUND，不会与UI线程抢占资源； 缺点： Api实现版本不一致问题：在Android1.5时AsyncTask的执行是串行的，在Android1.5——3.0之间- AsyncTask是并行的，而到了Android3.0之后AsyncTask的执行又回归到了串行。当然目前我们兼容的最低版本一般都会是最低4.0，那么就不需要对其进行过多的自定义适配，但是一定要注意AsyncTask默认是串行的，用于多线程场景下的话需要调用其重载方法executeOnExecutor()传入自定义的线程池，并且自己处理好同步问题； 匿名内部类默认持有外部类的引用，有内存泄漏的风险。备注：对于AsyncTask正确的使用姿势，就是区分场景调用不同的执行方法；并且避免出现内存泄漏的问题。 HandlerThread通过HandlerThread可以创建一个带有looper的线程，引入了Handler、Looper、MessageQueue等概念，可以实现对工作线程的调度。 以下是HandlerThread的使用示例： HandlerThread handlerThread = new HandlerThread(&quot;DataBase Opeartion&quot;, Process.THREAD_PRIORITY_BACKGROUND); handlerThread.start(); Handler handler = new Handler(handlerThread.getLooper()){ @Override public void handleMessage(Message msg) { // Do DataBase Opeartion } }; 优点： 串行执行，没有并发带来的问题； 不退出的前提下一直存在，避免线程相关的对象频繁重建和销毁造成的资源消耗。 缺点： 串行执行（不同的视角优点也变缺点），并发场景下无能为力； 不指定优先级的情景下默认优先级为THREAD_PRIORITY_DEFAULT，与UI线程同级别。备注：HandlerThread的正确使用姿势：串行场景，并在构造方法中明确指定优先级。 IntentService根据官方文档的描述：IntentService是继承于Service并处理异步请求的一个类，在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方式和启动传统Service一样，同时，当任务执行完后，IntentService会自动停止，而不需要我们去手动控制。另外，可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个耗时操作，依次执行。实际上IntentService是Service与HandlerThread的组合，内部的工作线程以及调度机制都依赖于HandlerThread。 @Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } @Override public void onDestroy() { mServiceLooper.quit(); } 优势： 同HandlerThread的优势； 开启服务，进程优先级会提升； 无需手动关闭，执行完之后自动结束。 三、线程池线程池：基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多(存活状态)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。 优势： 线程的创建和销毁由线程池维护，一个线程在完成任务后并不会立即销毁，而是由后续的任务复用这个线程，从而减少线程的创建和销毁，节约系统的开销； 线程池旨在线程的复用，这就可以节约我们用以往的方式创建线程和销毁所消耗的时间，减少线程频繁调度的开销，从而节约系统资源，提高系统吞吐量； 在执行大量异步任务时提高了性能； Java内置的一套ExecutorService线程池相关的api，可以更方便的控制线程的最大并发数、线程的定时任务、单线程的顺序执行等。 备注：回到我们上面提的第三个问题：线程池一定会提升效率吗？ 使用线程池需要特别注意同时并发线程数量的控制。因为CPU只能同时执行固定数量的线程数，一旦同时并发的线程数量超过CPU能够同时执行的阈值，CPU就需要花费精力来判断到底哪些线程的优先级比较高，在不同的线程之间进行调度切换。一旦同时并发的线程数量达到一定的量级，CPU在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降； 每开一个新的线程，都会耗费至少64K以上的内存。线程池中存在了过多的并发数量不仅会影响CPU的调度时间而且会减少可用内存； 线程的优先级具有继承性，在某线程中创建的线程会继承此线程的优先级。那么我们在UI线程中创建了线程池，其中的线程优先级是和UI线程优先级一样的；所以仍然可能出现20个同样优先级的线程平等的和UI线程抢占资源。 对于线程池中线程数量的限制，可以参考AsyncTask中的配置，基于7.0源码，不同版本的实现可能有细微差别; // We want at least 2 threads and at most 4 threads in the core pool, // preferring to have 1 less than the CPU count to avoid saturating // the CPU with background work 核心池数量被限定在2到4之间。 private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4)); private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; private static final int KEEP_ALIVE_SECONDS = 30; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 四、总结 Thread、AsyncTask适合处理单个任务的场景； HandlerThread适合串行处理多任务的场景； IntentService适合处理与UI无关的多任务场景； 当需要并行的处理多任务之时，ThreadPoolExecutor是更好的选择，当然也可以使用AsyncTask传入自定义的线程池； 注意线程优先级的设置； 特别注意对不同场景下异步方式的选择。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化（四）之启动速度优化]]></title>
      <url>%2F2017%2F06%2F13%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[一、前言一款好的产品应该集界面美观、操作流畅、功能稳定于一身，但是随着App功能的增多，App的性能问题会逐渐暴露出来，比如卡顿、闪退等现象。这些性能问题极大的影响了用户体验。因此，在APP的开发维护中，预防和解决性能问题显得尤为重要。日常工作和学习中，我也比较重视这一块的实战和总结，但性能优化是个大话题，我将用一个专题来记录，作为今后开发的Check List。 APP的启动速度是用户体验的第一扇门，所以第一篇文章就从应用的启动优化开始，优化APP的启动速度。 二、启动加速概述Google官方文档《Launch-Time Performance》将应用的启动分为冷启动、热启动、温启动三种。 冷启动 应用程序自设备启动以来第一次启动或系统杀死应用程序等情况（后台没有该应用的进程）下启动应用，这种方式叫冷启动； 热启动 当启动应用时，后台已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台），启动的时候会从已有的进程中来启动应用，这个方式叫热启动。 温启动 用户退出应用，但随后重新启动。该过程应用程序必须通过调用onCreate()从头开始重新创建活动。进程和Activity需要重新启动，但任务可以从保存的实例状态包传递到onCreate（）中。 通过上面的描述可以得知冷启动这种类型的启动在优化启动速度方面挑战最大，因为系统和应用程序比其他启动状态需要做更多的工作。 应用在冷启动之前，需要执行三个任务： 加载启动App； App启动之后立即展示出一个空白的Window； 创建App的进程； 而这三个任务执行完毕之后会马上执行以下任务： 创建App对象； 启动Main Thread； 创建启动的Activity对象； 加载View； 布置屏幕； 进行第一次绘制； 而一旦App进程完成了第一次绘制，系统进程就会用Main Activity替换已经展示的Background Window，此时用户就可以使用App了。 上述流程里面大多数步骤都是由系统控制的，作为普通应用，可以优化的也就是以下3个方面： 利用闪屏图，视觉加速； 优化Application的onCreate流程 优化Activity的onCreate流程 接下来将针对这3点优化方向具体展开 三、启动加速之闪屏图使用Activity的windowBackground主题属性可以为启动的Activity提供一个简单的drawable，实现闪屏图效果 Layout XML file: &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:opacity=&quot;opaque&quot;&gt; &lt;!-- The background color, preferably the same as your normal theme --&gt; &lt;item android:drawable=&quot;@android:color/white&quot;/&gt; &lt;!-- Your product logo - 144dp color version of your app icon --&gt; &lt;item&gt; &lt;bitmap android:src=&quot;@drawable/product_logo_144dp&quot; android:gravity=&quot;center&quot;/&gt; &lt;/item&gt; &lt;/layer-list&gt; Manifest file: &lt;activity ... android:theme=&quot;@style/AppTheme.Launcher&quot; /&gt; onCreate： public class MyMainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { // Make sure this is before calling super.onCreate setTheme(R.style.Theme_MyApp); super.onCreate(savedInstanceState); // ... } } 目前大多数应用都会使用这种方式来替换系统默认的启动窗口，不仅可以作为品牌宣传页，还可以视觉上产生一种快速启动APP的感觉。也有些APP通过关闭启动窗口属性android:windowDisablePreview的方式来直接移除系统默认的启动窗口，但是这样的弊端是用户从点击桌面图标到真的看到实际页面的这段时间当中，画面没有任何变化，实际上是将启动延迟的锅丢给了手机开发商。 不过上述方式其实并没有真正的实现启动速度优化，只是通过视觉体验来优化了交互效果。 四、启动加速之Application通常我们会在Application里面做一些第三方组件、数据库等初始化工作，但如果不做选择，所有的初始化工作都放到Application的主线程中处理，必然会导致主线程阻塞，拖慢APP的启动速度。所以，在Application的onCreate里面，我们需要根据组件的功能重要程度以及优先级，按照如下两种方案处理： 异步加载，不阻塞主线程； 数据库及IO操作都移到工作线程，尝试设置线程优先级为THREAD_PRIORITY_BACKGROUND，这样工作线程最多能获取到10%的时间片，优先保证主线程执行。 延迟加载，延迟到组件真正被调用到的时候再做加载 是否可以延迟加载取决组件的调用关系以及具体业务的需要。保证一个准则：可以异步的都异步，不可以异步的尽量延迟。让应用先启动，再操作。 五、启动加速之Activity在Activity的创建加载过程中，会执行很多操作，例如设置页面的主题，初始化页面的布局，加载图片，获取网络数据，读写SharedPreference等。上述操作的任何一个环节出现性能问题都可能导致画面不能及时显示，影响APP的启动速度。 对Activity启动做性能优化，我们需要考虑以下两点： 优化布局耗时：一个布局层级越深，里面包含需要加载的元素越多，就会耗费更多的初始化时间。 异步延迟加载：一开始只初始化最需要的布局；异步加载图片，非立即需要的组件可以做延迟加载。 五、常用工具：1.display time从Android KitKat（4.4）版本开始，Logcat中会输出从程序启动到某个Activity显示到画面上所花费的时间。这个方法比较适合测量程序的启动时间。 2.adb命令通过ADB命令也可以统计应用的启动时间： adb shell am start -W [packageName]/[packageName.MainActivity] 指标含义：ThisTime:一般和TotalTime时间一样，除非在应用启动时开了一个透明的Activity预先处理一些事再显示出主Activity，这样将比TotalTime小；TotalTime:应用的启动时间，包括创建进程+Application初始化+Activity初始化到界面显示；WaitTime: ActivityManagerService启动App的Activity时的总时间，一般比ToatalTime大。 3.调用Activity的reportFullyDrawn()方法上面两种方式统计到的启动时间是自动报告的，对于使用异步加载（程序界面已经显示，可是内容却还在加载）的情况就无法很好的统计时间了。为了统计异步加载所耗费的时间，我们可以在异步加载完毕之后调用Activity的reportFullyDrawn()方法获取整个加载的耗时。 在4.4上调用reportFullyDrawn()方法会崩溃（但是log还是能正常打印），提示需要UPDATE_DEVICE_STATS权限 ，但是这个权限只有系统app才能授权。解决的办法是这样调用： try{ reportFullyDrawn(); }catch(SecurityException e){ } reportFullyDrawn()方法显示的log类似display time。 4.Method Tracing计算出APP启动的总时间后，我们需要分析具体的耗时细节。为了获取具体的耗时分布情况，我们可以使用Android studio自带的Method Tracing工具来进行详细的测量。 六、总结 利用闪屏图； 异步初始化组件； 梳理业务逻辑，延迟初始化组件、操作； 正确使用线程； 去掉无用代码、重复逻辑等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android源码阅读系列（四）之Android中的线程]]></title>
      <url>%2F2017%2F06%2F13%2FAndroid%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8BAndroid%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[一、引用Android中线程分为主线程和子线程，主线程主要处理和UI相关的操作，而主线程中则往往用于执行耗时操作，比如网络请求和I/O操作。除了Thread之外，Android中还有一些可以用来作为线程使用的类，如AsyncTask、HandlerThread 和 IntentService。经管他们的表现形式都和Thread有区别，但是本质上依然是线程。 二、Thread用法new Thread(){ @Override public void run() { super.run(); // NetWork or DataBase Operation } }.start(); 这是最简单的创建异步线程的姿势了，但是这样处理存在一些缺点： 创建及销毁线程消耗性能较大； 缺乏统一的管理； 优先级与UI线程一致，抢占资源处于同一起跑线； 匿名内部类默认持有外部类的引用，有内存泄漏的风险; 需要自己处理线程切换。 App启动阶段为避免在主线程创建线程池的资源消耗，使用的时候可以加上优先级的设置 new Thread () { @Override public void run() { super.run(); android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // NetWork or DataBase Operation } }.start(); 三、AsyncTaskAsyncTask是一种轻量级的异步任务类，可以在线程池中执行后台任务，然后把任务执行的进度和结果传递给主线程并在主线程中更新UI。 public abstract class AsyncTask&lt;Params, Progress, Result&gt; AsyncTask是一个抽象类，它提供了Params, Progress 和 Result这三个泛型参数，其中Params表示参数的类型，Progress表示任务执行的进度的参数类型，Result则表示任务返回的结果的参数类型，实际使用中如果不需要传递具体的参数，可以使用Void。通常我们使用execute来启动AsyncTask @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); } } mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; } public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; 可以看到execute方法会调用executeOnExecutor，其中exec也就是sDefaultExecutor是一个线程池 private static class SerialExecutor implements Executor { final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } SerialExecutor的execute方法会把mFuture对象插入到mTasks这个队列中，如果这时mActive == null（没有正在活动的AsyncTask任务），就会调用SerialExecutor的scheduleNext方法使用线程池THREAD_POOL_EXECUTOR来执行任务，当一个任务执行完成后，会继续执行其他任务，直到所有任务都被执行。 AsyncTask中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR），其中SerialExecutor用于任务的排队，THREAD_POOL_EXECUTOR用于任务的执行。 从上面的分析可以看出，在默认情况下，AsyncTask是串行执行的。 其实AsyncTask不同版本是有差异的，比如Android1.5是串行的，1.6之后是并行的，但是到3.0以后的版本又改为串行了。当然，如果我们想在3.0以后也使用并行的方式执行任务，根据上面的分析，我们可以直接调用executeOnExecutor，直接传入一个THREAD_POOL_EXECUTOR（执行任务的线程池），这样就可以直接执行，不用将任务加到SerialExecutor这个排队的线程池了。 在使用AsyncTask过程中，我们通常会在onPostExecute做一些涉及到UI的操作 @WorkerThread protected abstract Result doInBackground(Params... params); @MainThread protected void onPostExecute(Result result) { } 从源码可以得知，任务是在doInBackground这个子线程中进行的，最终任务执行结果会通过onPostExecute返回，而onPostExecute是在主线程中，那么根据Android消息机制可以推测，这中间必然会用到Handler private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } finish方法里面将result传递给了onPostExecute private static class InternalHandler extends Handler { public InternalHandler() { super(Looper.getMainLooper()); } @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;}) @Override public void handleMessage(Message msg) { AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } InternalHandler的handleMessage里面调用了finish方法 private static Handler getHandler() { synchronized (AsyncTask.class) { if (sHandler == null) { sHandler = new InternalHandler(); } return sHandler; } } private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; } public AsyncTask() { mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Result result = null; try { Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); } catch (Throwable tr) { mCancelled.set(true); throw tr; } finally { postResult(result); } return result; } }; ... } 从源码可以看到，任务在doInBackground里面执行完成后，借助InternalHandler实现了从子线程到主线程的切换。 由于getHandler方法是静态方法，返回的sHandler是一个静态对象，为了能够从工作线程切换到主线程，getHandler这个方法必须在主线程中调用了，而静态方法是在加载类的时候初始化的，所以最终结果就是AsyncTask必须在主线程中加载。 四、HandlerThreadAndroid中Handler一般都在主线程中使用，使用Handler需要创建Looper消息循环和MessageQueue消息队列，由于主线程里面系统已经自动帮我们执行了创建上传创建，所以我们可以很方便的使用Handler。但是如果需要在子线程里面使用Handler，就需要严格按照流程，先创建Looper消息循环和MessageQueue消息队列了。比如像下面这样： Thread thread = new Thread(new Runnable() { @Override public void run() { Looper.prepare(); Looper.loop(); } }); thread.start(); Handler handler = new Handler(newThread.getLooper()); 这种使用方式是有问题的，thread的looper是在线程运行之后创建的，当执行到Handler handler = new Handler(thread.getLooper())的时候，thread的looper可能还没有创建好。 为此，Android专门提供了HandlerThread类 Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called. public class HandlerThread extends Thread { ... @Override public void run() { mTid = Process.myTid(); Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } ... public Looper getLooper() { if (!isAlive()) { return null; } // If the thread has been started, wait until the looper has been created. synchronized (this) { while (isAlive() &amp;&amp; mLooper == null) { try { wait(); } catch (InterruptedException e) { } } } return mLooper; } ... } 从文档说明可以看到，HandlerThread帮我们创建好了Looper，进一步分析源码，HandlerThread继承了Thread，他的run方法里面通过Looper.prepare()创建了消息队列，并通过Looper.loop()开启了消息循环，getLooper()方法里面当Looper未创建时会调用wait方法，当run方法里面Looper创建完成后调用notifyAll返回创建的Looper对象。这样就解决了上面例子中存在的异步问题。不过从源码也可以看到，HandlerThread只是帮我们处理异步问题，由于run方法是一个无限循环，因此当结束时有HandlerThread时，我们需要手动调用quit或者quitSafely方法来终止线程的执行。 五、IntentServiceIntentService是一种特殊的Service，可以用来执行后台耗时的任务，由于IntentSerice是服务，所以它的优先级会比单纯的线程高很多，不容易被系统杀死，因此比较适合执行一些高优先级的后台任务。 public abstract class IntentService extends Service { ... @Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } ... } 从onCreate里面可以看到IntentService使用了HandlerThread和Handler，从上面关于HandlerThread的分析可以知道这里的Handler是子线程的，里面是可以执行耗时任务的，这也是IntentService可以执行后台耗时任务的原因。当IntentService启动后执行到onStartCommand时，会再执行onStart @Override public void onStart(@Nullable Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } 可以看到，在onStart里面，通过mServiceHandler发送了一条消息，这个消息会在HandlerThread中处理。 @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent); 在onHandleIntent就可以执行后台耗时任务了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android源码阅读系列（三）之Android消息机制]]></title>
      <url>%2F2017%2F06%2F11%2FAndroid%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8BAndroid%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[一、引言Android开发中经常需要在子线程和主线程间切换，通常我们会在子线程中做一些耗时的操作，比如网络请求或者I/O操作，当耗时操作完成后可能需要在UI上做一些更新，由于Android开发不能在子线程中操作UI控件（UI控件不是线程安全的），这个时候就需要通过Handler将更新UI的操作切换到主线程中执行。Android的消息机制主要就是指Handler的运行机制，所以，研究Android消息机制，其实就是研究Handler的运行机制。 二、Handler消息发送Hnadler的工作主要包含消息发送和接收。消息发送可以通过post或者send系列方法来实现，post最终也会执行send方法。Android源码里面Handler消息发送流程如下： public final boolean sendMessage(Message msg) { return sendMessageDelayed(msg, 0); } public final boolean sendMessageDelayed(Message msg, long delayMillis) { if (delayMillis &lt; 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 通过源码可以知道，Handler消息发送过程就是像MessageQueue中插入了一条消息。 三、MessageQueue消息插入通过分析Hnadler消息发送的源码可以得知，消息发送的结果就是使用enqueueMessage向MessageQueue里面插入了一条消息，Android源码中enqueueMessage方法如下： boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } 通过源码可以知道，enqueueMessage就是像Message的单链表里面插入了消息。没有什么特殊的。回到源码中查看类的说明，有这样一段： Low-level class holding the list of messages to be dispatched by a{@link Looper}. Messages are not added directly to a MessageQueue,but rather through {@link Handler} objects associated with the Looper. 里面提到另一个对象，Looper。 三、Looper交互通过上面的分析可以知道，Hnadler消息发送会将消息插入到MessageQueu中，MessageQueue和Looper会有交互。在Looper源码里面有一个关于如何在线程中使用Hnadler的例子： class LooperThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); mHandler = new Handler() { public void handleMessage(Message msg) { // process incoming messages here } }; Looper.loop(); } } 从这个例子可以看出，在线程中使用Hnadler需要先调用Looper的prepare方法，看一下这个prepare方法： public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed)); } 最终调用了Looper的构造方法， private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 构造方法里面创建一个MessageQueue，也就是prepare其实是创建了Looper再看一下loop这个方法： /** * Run the message queue in this thread. Be sure to call * {@link #quit()} to end the loop. */ public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) { logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); } final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) { Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); } try { msg.target.dispatchMessage(msg); } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } if (logging != null) { logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); } msg.recycleUnchecked(); } } 从方法说明里面可以看到，这个方法是必须要调用的。这个方法是一个死循环，Looper通过MessageQueue的next方法读取消息，当MessageQueue的next方法返回null的时候才结束循环，如果next返回的消息不为空，就会调用msg.target.dispatchMessage这个方法。 四、MessageQueue消息读取通过上面的分析可以知道，Looper会调用MessageQueue的next方法读取消息 Message next() { ... Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } .... } 从源码可以知道，next方法返回了从Handler插入到MessageQueue里面的消息。 五、Handler消息接收在分析Looper的过程可以得知，Looper通过MessageQueue的next方法读取MessageQueue里面插入的消息，读取到消息时，会调用msg.target.dispatchMessage方法，msg是从MessageQueue里面读取的，而MessageQueue里面的消息又是通过Handler插入的，回到Handler的enqueueMessage方法 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 可以看到，msg.target其实就是当前的Handler,看一下dispatchMessage方法 /** * Handle system messages here. */ public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 最终调用了handleMessage来处理消息。 六、Hnadler消息机制通过上面的分析可以得知： MessageQueue（消息队列）通过单链表的数据结构来维护消息列表，主要包含两个操作：插入和读取。插入和读取对应的方法分别为enqueueMessage和next。 Looper在Android的消息机制中扮演者消息循环的角色, 通过死循环不停地从MessageQueue中查看是否有新消息. 如果有新消息就会处理. 否则就一直阻塞在那里。 Handler主要包含消息发送和接收过程. Handler发送消息的过程就是向MessageQueue中插入一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后交由Handler处理，Handler的dispatchMessage方法会被调用，这时Handler就进入了消息接收的阶段(handleMessage)。 七、补充分析Looper源码时，在线程中使用Handler需要先构建Looper，但是我们平时在主线程（UI线程）里面使用Handler时都是直接创建的Handler，并没执行构建Looper的操作。其实主线程也是有构建Looper的，只不过这一步操作是系统替我们做的，可以查看ActivityThread的源码 public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ... } 通过查看ActivityThread的源码可以看到，主线程通过Looper.prepareMainLooper已经自动构建了Looper，所以，主线程里面关于Handler使用方法和上面的分析过程也是统一的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化（三）之读书笔记]]></title>
      <url>%2F2017%2F06%2F11%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Android性能优化主要几个方面: 布局优化 绘制优化 内存泄漏优化 响应速度优化 ListView, Bitmap, 线程优化 布局优化布局优化的思想就是尽量较少布局文件的层级,这就可以让Android绘制时的工作量减少 删除无用的控件和层级, 有选择地使用ViewGroup. 例如RelativeLayout和LinearLayout. 都可以的话那么就采用LinearLayout. 因为RelativeLayout的功能比较复杂, 它的布局过程需要花费更多的CPU时间. FrameLayout和LinearLayout都是一种简单高效的ViewGroup. 如果需要嵌套才可以实现的布局那么就是用RelativeLayout. 布局优化的另外一个方法就是采用标签, 标签和ViewStub. include主要用于布局的重用 merge一般和include标签配合使用, 它可以减少布局的层级 ViewStub: 提供了按需加载的功能, 当需要时才会将ViewStub中的布局加载到内存,这可以提高程序的初始化. include标签 可以将一个指定的布局文件加载到当前布局文件中: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;include android:id=&quot;@+id/hah&quot; android:layout=&quot;@layout/layout_titlebar&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; android:visibility=&quot;invisible&quot;/&gt; &lt;/LinearLayout&gt; 这个标签里面支持的属性很少, 根据编辑器的提示只有5个, 而且width和height如果要出现需要同时出现, 也可以不写, 最重要的就是一个必须指定导入的布局layout=”xxxxxx”. merge 这个标签一般和include标签一起使用从而减少布局的层级. 有时候会有这样一个场景, 如果include导入的布局的根布局是竖直方向的, 而当前布局也是竖直方向的, 那么和显然有一个层级是多余的. 这个时候使用就可以去掉重复布局. ViewStub ViewStub继承了View, 这是一个非常轻量级的且宽高都是0, 因此它本身不参与任何的布局和绘制过程. 而ViewStub存在的意义在于按需加载所需的布局文件, 在实际开发中, 有很多布局文件在正常情况系不会显示, 如网络异常等. 这个时候就没有必要再整个界面初始化的时候将其加载. 首先布局中添加 &lt;ViewStub android:id=&quot;@+id/stub_import&quot; android:inflatedId=&quot;@+id/stin_root&quot; android:layout=&quot;@layout/layout_stubview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot;/&gt; 这里android:layout属性还是导入外部布局的意思. inflatedId这个添加的id的属性是给导入进来的布局layout_stubview的根布局设定了一个id值. 然后在代码中有两种方式让其显示 // 方式一 通过设置visibility ((ViewStub)findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); // 方式二 通过inflate加载显示 //View inflate = ((ViewStub) findViewById(R.id.stub_import)).inflate(); // 通过inflatedId这个id可以得到加载进来的布局的根布局 LinearLayout commLv = (LinearLayout) findViewById(R.id.stin_root); 绘制优化绘制优化是指View#onDraw()方法要避免执行大量的操作.两个方面 onDraw中不要创建新的局部对象, 因为onDraw()方法可能会被频繁调用, 这样就会在一瞬间产生大量的临时对象, 这不仅占用了过多的内存而且还会导致系统频繁的gc, 降低了程序的执行效率. 不要做耗时任务, 也不能执行成千上万次的循环操作. 即使每次循环都很轻量级, 但是大量的循环仍然十分抢占CPU的时间片, 这会造成View的绘制流程不流畅. 按照官方的规范, View的绘制帧率保证60fps最佳. 也就是16ms的为每一阵帧的绘制时间. 内存泄漏优化情况1. 静态变量导致的内存泄漏private static View sView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sView = new View(this); } 如非必须传递Activity的引用不要这么做, 如果需要上下文可以传递getApplicationContext()返回的上下文 情况2. 单例模式导致的内存泄漏常见的就是在使用注册监听的时候, 往往会往一个单例类中传入this本类对象,进行注册, 然后却没有解注册的动作. 那么这个Activity被引用的时间也就是和Application的生命周期持平. 情况3. 属性动画导致的内存泄漏在Android 3.0中加入了属性动画, 属性动画有一类无限循环的动画, 如果在Activity中播放此类动画且没有在Activity退出的时候没有停止动画. 尽管无法界面上看到效果, 但是创建这个动画所关联的View被动画所持有, 而View又持有了Activity, 最终Activity无法释放. 解决方案, 就是在onDestroy()中调用动画的cancel()来停止动画. 响应速度和ANR日志分析响应速度的优化核心就是避免主线程做耗时操作, 响应速度过慢更多体现在Activity启动的速度上. 如果主线程内做太多的事情, 会导致Activity启动时出现黑屏现象, 甚至出现ANR. Android中规定如果Activity5秒钟之内无法响应屏幕事件或者键盘输入事件就会出现ANR. 而BroadCastReceiver如果10秒之内还未执行完操作也会出现ANR. 如果进程发生了ANR以后, 系统会在data/anr目录下创建一个文件traces.txt. 通过分析这个文件就定位出原因.(这个文件很长如果需要分析, 请先删除文件生成一个在分析来进行了解) 通过一个例子来了解如何去分析文件, 首先在onCreate()添加如下代码, 让主线程等待一个锁,然后点击返回5秒后会出现ANR, 贴代码 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 以下代码是为了模拟一个ANR的场景来分析日志 new Thread(new Runnable() { @Override public void run() { testANR(); } }).start(); SystemClock.sleep(10); initView(); } /** * 以下两个方法用来模拟出一个稍微不好发现的ANR */ private synchronized void testANR(){ SystemClock.sleep(3000 * 1000); } private synchronized void initView(){} 这样会出现ANR, 然后导出/data/anr/straces.txt文件. 因为内容比较多只贴出关键部分 DALVIK THREADS (15): &quot;main&quot; prio=5 tid=1 Blocked | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x73db0970 self=0xf4306800 | sysTid=19949 nice=0 cgrp=apps sched=0/0 handle=0xf778d160 | state=S schedstat=( 151056979 25055334 199 ) utm=5 stm=9 core=1 HZ=100 | stack=0xff5b2000-0xff5b4000 stackSize=8MB | held mutexes= at com.szysky.note.androiddevseek_15.MainActivity.initView(MainActivity.java:0) - waiting to lock &lt;0x2fbcb3de&gt; (a com.szysky.note.androiddevseek_15.MainActivity) - held by thread 15 at com.szysky.note.androiddevseek_15.MainActivity.onCreate(MainActivity.java:42) 这段可以看出最后指明了ANR发生的位置在ManiActivity的42行. 并且通过上面看出initView方法正在等待一个锁锁的类型是一个MainActivity对象. 并且这个锁已经被线程id为15(tid=15)的线程持有了. 接下来找一下线程15 &quot;Thread-404&quot; prio=5 tid=15 Sleeping | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c00f80 self=0xeb95bc00 | sysTid=19985 nice=0 cgrp=apps sched=0/0 handle=0xef34be80 | state=S schedstat=( 391248 0 1 ) utm=0 stm=0 core=2 HZ=100 | stack=0xe2bfe000-0xe2c00000 stackSize=1036KB | held mutexes= at java.lang.Thread.sleep!(Native method) - sleeping on &lt;0x2e3896a7&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1031) - locked &lt;0x2e3896a7&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:985) at android.os.SystemClock.sleep(SystemClock.java:120) at com.szysky.note.androiddevseek_15.MainActivity.testANR(MainActivity.java:50) - locked &lt;0x2fbcb3de&gt; (a com.szysky.note.androiddevseek_15.MainActivity) - tid = 15 就是相关信息如上, 首行已经标出线程的状态为Sleeping, 原因在50行, 就是SystemClock.sleep(3000 * 1000);这句话. 也就是testANR(). 而最后一行也表明了持有的locked&lt;0x2fbcb3de&gt;就是主线程在等待的那个锁对象. ListView和Bitmap优化 ListView: 在前面已经说过了, 主要三个方面: 采用ViewHolder避免在getView中执行耗时操作; 其次要根据列表的滑动状态来控制任务的执行频率; 最后可以尝试开启硬件加速是ListView滑动更加流畅. ListView的优化策略也完全适用于GridView Bitmap: 也已经说过, 主要是通过BitmapFactory.Options根据需要对图片进行采样, 采样率的设置通过inSampleSize属性. 线程优化主要思想就是采用线程池, 避免程序中存在大量的Thread. 线程池可以重用内部的线程, 避免了线程创建和销毁的性能开销. 同时线程池还能有效的控制线程的最大并发数, 避免了大量线程因互相巷战系统资源从而导致阻塞现象的发生. 额外的性能优化建议 避免创建过多的对象 不要过多使用枚举, 枚举占用的内存空间比整形还要大,使用Android官方提供的方法可参考另一篇博客链接跳转 常量请使用 static final 来修饰 使用一些Android特有的数据结构, 比如SparseArray和Pair等 适当的使用软引用和弱引用 采用内存缓存和磁盘缓存 尽量采用静态内部类, 避免潜在的由于内部类而导致的内存泄漏 内存泄漏分析工具MATMAT全程Eclipse Memory Analyzer, 是一个内存泄漏分析工具. 下载后解压即可. 下载地址http://www.eclipse.org/mat/downloads.php. 这里仅简单说一下. 这个我没有手动去实践, 就当个记录, 因为现在Android Studio可以直接分析hprof文件. 可以手动写一个会造成内存泄漏的代码, 然后打开DDMS, 然后选中要分析的进程, 然后单击Dump HPROF file这个按钮. 等一小段会生成一个文件. 这个文件不能被MAT直接识别. 需要使用Android SDK中的工具进行格式转换一下.这个工具在platform-conv文件夹下 hprof-conv 要转换的文件名 输出的文件名 文件名的签名有包名. 然后打开MAT通过菜单打开转换后的这个文件. 这里常用的就有两个 Histogram: 可以直观的看出内存中不同类型的buffer的数量和占用内存大小 Dominator Tree: 把内存中的对象按照从大到小的顺序进行排序, 并且可以分析对象之间的引用关系, 内 存泄漏分析就是通过这个完成的.分析内存泄漏的时候需要分析Dominator Tree里面的内存信息, 一般会不直接显示出来, 可以按照从大到小的顺序去排查一遍. 如果发生了了泄漏, 那么在泄漏对象处右键单击Path To GC Roots-&gt;exclude wake/soft references. 可以看到最终是什么对象导致的无法释放. 刚才的操作之所以排除软引用和弱引用是因为,大部分情况下这两种类型都可以被gc回收掉,所以基本也就不会造成内存泄漏. 同样这里也可以使用搜索功能, 假如我们手动模拟了内存泄漏, 泄漏的对象就是Activity那么我们back退出重进循环几次, 会发现其实很多个Activit对象. 更多的东西我也不会,作者也没有说.. 不过这些以后Android Studio都会很有好用对应功能. 提高程序的可维护性这里主要说Android的程序设计思想. 主旨是如何提高代码的可维护性和可扩展性, 而程序的可维护性也包含可扩展性. 这里的切入点为: 代码风格, 代码的层次性和单一职责原则, 面向扩展编程以及设计模式 可读性是代码可维护性的前提, 一段只能让机器读懂的代码即使可以跑也属于”坏味道的代码”, 而良好的代码风格在一定程度上可以提高从程序的可读性. 代码的风格有 命名规范, 代码排版, 注释说明. 命名要规范, 正确传达出变量或者方法的定义, 少用缩写除非业界通用的缩写如String-&gt;str.能让人一眼明白的. 私有成员要以m开头. 静态成员要以s开头. 常量要全部大写. 代码排版上留出合理的空白来区分不同的代码块, 其中同类变量的声明放在一组, 两类变量之间留出一行作为空白. 仅为非常关键的代码添加注释, 其他地方不写注释, 这就对变量和方法的命名风格提出了很高的要求. 一个合理的命名风格可以让读者阅读源码的时候就如阅读注释一样. 因此根本不需要为代码额外写注释 代码的层次是指代码要有分层的概念, 对于一段业务逻辑, 不要试图在一个方法或者一个类中去全部实现, 而是将其分成几个子逻辑, 然后每个逻辑做自己的事情, 这样即显得代码层次分明, 又可以分解任务从而实现简单逻辑的效果. 单一职责是和层次性相关联的. 代码分层以后, 每一层仅仅关注少量的逻辑, 这样就做到了单一职责. 程序的扩展性, 由于很多时候在开发过程中无法保证已经做好的需求不在后面的版本发生更改, 因此在写程序的时候要时刻考虑到扩展的问题, 考虑如果这个逻辑以后发生了改变那么哪些需要修改, 以及怎样在以后修改的时候降低工作量, 而面向扩展编程可以让程序具有很好的扩展性. 适当使用设计模式可以提高代码的可维护性和可扩展性. 但是一定控制设计的度, 千万别过度设计.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android源码阅读系列（二）之Toast显示原理]]></title>
      <url>%2F2017%2F06%2F07%2FAndroid%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8BToast%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[一、引言在Android中Toast使用频率是相当高的，可以用来做用户提示，也可以在测试的时候方便的显示测试结果，关键是它使用方法非常简单，一行代码就搞定了 Toast.makeText(this, msg , Toast.LENGTH_SHORT).show(); 但是使用久了就有个疑问，Toast.LENGTH_SHORT和Toast.LENGTH_LONG是用于设置Toast显示时长的，但是这两个时长到底是多少呢？去到Toast源码发现这两个参数是final类型的 public static final int LENGTH_LONG = 1; public static final int LENGTH_SHORT = 0; LENGTH_LONG的值是1，LENGTH_SHORT的值是0，理论上当我们设置显示时长为LENGTH_SHORT时，Toast应该会一闪而逝，毕竟是0嘛，但是我们知道，实际使用并不是这样的，设置显示时长为LENGTH_SHORT时，Toast依然会停留2秒左右。看来，这个参数不是那么简单了。无果，只能深入源码分析下Toast的显示原理了。 二、Toast显示原理首先我们看下显示Toast时所用到的show方法 public void show() { if (mNextView == null) { throw new RuntimeException(&quot;setView must have been called&quot;); } INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try { service.enqueueToast(pkg, tn, mDuration); } catch (RemoteException e) { // Empty } } 从上面的代码可以看到，显示Toast的过程用到了NotificationManagerService的enqueueToast方法 // Toasts // ============================================================================ public void enqueueToast(String pkg, ITransientNotification callback, int duration) { if (DBG) Slog.i(TAG, &quot;enqueueToast pkg=&quot; + pkg + &quot; callback=&quot; + callback + &quot; duration=&quot; + duration); if (pkg == null || callback == null) { Slog.e(TAG, &quot;Not doing toast. pkg=&quot; + pkg + &quot; callback=&quot; + callback); return ; } final boolean isSystemToast = isCallerSystem() || (&quot;android&quot;.equals(pkg)); if (ENABLE_BLOCKED_TOASTS &amp;&amp; !noteNotificationOp(pkg, Binder.getCallingUid())) { if (!isSystemToast) { Slog.e(TAG, &quot;Suppressing toast from package &quot; + pkg + &quot; by user request.&quot;); return; } } synchronized (mToastQueue) { int callingPid = Binder.getCallingPid(); long callingId = Binder.clearCallingIdentity(); try { ToastRecord record; int index = indexOfToastLocked(pkg, callback); // If it&apos;s already in the queue, we update it in place, we don&apos;t // move it to the end of the queue. if (index &gt;= 0) { record = mToastQueue.get(index); record.update(duration); } else { // Limit the number of toasts that any given package except the android // package can enqueue. Prevents DOS attacks and deals with leaks. if (!isSystemToast) { int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) { final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) { count++; if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) { Slog.e(TAG, &quot;Package has already posted &quot; + count + &quot; toasts. Not showing more. Package=&quot; + pkg); return; } } } } record = new ToastRecord(callingPid, pkg, callback, duration); mToastQueue.add(record); index = mToastQueue.size() - 1; keepProcessAliveLocked(callingPid); } // If it&apos;s at index 0, it&apos;s the current toast. It doesn&apos;t matter if it&apos;s // new or just been updated. Call back and tell it to show itself. // If the callback fails, this will remove it from the list, so don&apos;t // assume that it&apos;s valid after this. if (index == 0) { showNextToastLocked(); } } finally { Binder.restoreCallingIdentity(callingId); } } } enqueueToast方法有三个参数，第一个参数当前应用的包名，第二个参数是一个callback，第三个参数duration，就是我们创建Toast时设置的显示时长，这个参数又参与了ToastRecord的初始化 private static final class ToastRecord { final int pid; final String pkg; final ITransientNotification callback; int duration; ToastRecord(int pid, String pkg, ITransientNotification callback, int duration) { this.pid = pid; this.pkg = pkg; this.callback = callback; this.duration = duration; } ... } 继续往下看，会执行showNextToastLocked()方法 private void showNextToastLocked() { ToastRecord record = mToastQueue.get(0); while (record != null) { if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); try { record.callback.show(); scheduleTimeoutLocked(record, false); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Object died trying to show notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // remove it from the list and let the process die int index = mToastQueue.indexOf(record); if (index &gt;= 0) { mToastQueue.remove(index); } keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) { record = mToastQueue.get(0); } else { record = null; } } } } 里面有一个scheduleTimeoutLocked方法，考虑到我们要研究的是显示时长，这个方法很明显和超时设置有关，进去看一下 private void scheduleTimeoutLocked(ToastRecord r, boolean immediate) { Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = immediate ? 0 : (r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY); mHandler.removeCallbacksAndMessages(r); mHandler.sendMessageDelayed(m, delay); } 太好了，Toast.LENGTH_LONG这个参数出现了，这里面根据r.duration计算出了delay的值，通过上面的分析，r.duration就是我们创建Toast时设置的时长，所以当我们设置的时长是Toast.LENGTH_LONG时，delay为LONG_DELAY，当设置LENGTH_SHORT时，delay为SHORT_DELAY private static final int LONG_DELAY = 3500; // 3.5 seconds private static final int SHORT_DELAY = 2000; // 2 seconds 通过源码我们可以看到这两个时长分别的3.5秒和2秒，从scheduleTimeoutLocked的源码里面也可以大概看出scheduleTimeoutLocked通过Handler发送了一个延时消息，最终WorkerHandler会接收消息并处理 private final class WorkerHandler extends Handler { @Override public void handleMessage(Message msg) { switch (msg.what) { case MESSAGE_TIMEOUT: handleTimeout((ToastRecord)msg.obj); break; } } } private void handleTimeout(ToastRecord record) { if (DBG) Slog.d(TAG, &quot;Timeout pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); synchronized (mToastQueue) { int index = indexOfToastLocked(record.pkg, record.callback); if (index &gt;= 0) { cancelToastLocked(index); } } } private void cancelToastLocked(int index) { ToastRecord record = mToastQueue.get(index); try { record.callback.hide(); } catch (RemoteException e) { Slog.w(TAG, &quot;Object died trying to hide notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // don&apos;t worry about this, we&apos;re about to remove it from // the list anyway } mToastQueue.remove(index); keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) { // Show the next one. If the callback fails, this will remove // it from the list, so don&apos;t assume that the list hasn&apos;t changed // after this point. showNextToastLocked(); } } 可以看到，在指定延时之后，Toast被隐藏了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化（二）之Monkey性能测试]]></title>
      <url>%2F2017%2F06%2F07%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8BMonkey%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[一、Monkey简介Android的SDK 里面，Monkey的tools是一个命令行工具，当连接Android设备时，只要在命令行里输入相应命令就能运行tools； Monkey test是一项压力测试，可以在规定的次数范围内做任何随机的操作，随机操作包括点击、滑动、Application切换、横竖屏、应用关闭等等，用户能做的操作统统可以模拟； Monkey test跑出来crash的bug等级永远为1，版本release前，Monkey跑出的结果中crash要为0。业内标准：final release前，Monkey跑完的总次数应为25W次，其结果里不允许有nullPointException出现. 二、Monkey命令标准命令： abd devices 列出所有的已连接的设备（包括真机和虚拟机） adb shell 进入shell模式，查看data/data文件夹中的安装包情况 [adb shell] monkey [options] 栗子：adb shell monkey -v 500 产生500次随机事件，作用与系统中所有的activity（其实也不是所有的activity，而是包含 Intent.CATEGORY_LAUNCHER 或Intent.CATEGORY_MONKEY 的activity）。 三、命令分类 常用选项： -help：打印帮助信息-v：指定打印信息的详细级别，一个 -v增加一个级别 ， 默认级别为 0 ,最高为-v -v -v 事件选项； -s：指定产生随机事件种子值，相同的种子值产生相同的事件序列。如： -s 200 --throttle：每个事件结束后的间隔时间——降低系统的压力（如不指定，系统会尽快的发送事件序列）。如：--throttle 100 --pct-touch：指定触摸事件的百分比，如：--pct-touch 5% 相关的还有以下option： --pct-motion &lt;percent&gt; （滑动事件） --pct-trackball &lt;percent&gt; （轨迹球事件） --pct-nav &lt;percent&gt;（导航事件 up/down/left/right） --pct-majornav &lt;percent&gt; (主要导航事件 back key 、 menu key) --pct-syskeys &lt;percent&gt; (系统按键事件 Home 、Back 、startCall 、 endCall 、 volumeControl) --pct-appswitch &lt;percent&gt; （activity之间的切换） --pct-anyevent &lt;percent&gt;（任意事件） 约束选项： -p：指定有效的package（如不指定，则对系统中所有package有效），一个-p 对应一个有效package， 如： -p com.ckt -p com.ckt.asura； -c：activity必须至少包含一个指定的category，才能被启动，否则启动不了； 调试选项： –dbg-no-events：初始化启动的activity，但是不产生任何事件。为了得到最佳结果，把它与-v、一个或几个包约 束、以及一个保持Monkey运行30秒或更长时间的非零值联合起来，从而提供一个环境，可以监视应用程序所调用的包之间的转换 --hprof：指定该项后在事件序列发送前后会立即生成分析报告 —— 一般建议指定该项。 --ignore-crashes：忽略崩溃 --ignore-timeouts：忽略超时 --ignore-security-exceptions：忽略安全异常 --kill-process-after-error：发生错误后直接杀掉进程 --monitor-native-crashes：跟踪本地方法的崩溃问题 --wait-dbg：直到连接了调试器才执行monkey测试。 四、栗子：adb shell monkey -p com.ssjjsy.sdk.hk.demo -s 100 --throttle 10 --ignore-crashes --ignore-timeouts --monitor-native-crashes --pct-appswitch 30 --pct-majornav 20 --pct-nav 20 --pct-touch 20 --pct-motion 10 -v -v -v 10000 &gt; E:\Git\monkey_log.txt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android源码阅读系列（一）之SharedPreferences]]></title>
      <url>%2F2017%2F06%2F04%2FAndroid%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BSharedPreferences%2F</url>
      <content type="text"><![CDATA[一、引言SharedPreferences使用方法非常简单，是Android开发中使用频率非常高的轻量级存储方式，经常被用来存放一些键值对数据，比如配置信息等，得到了很多很多开发者的青睐。但是SharedPreferences并不是万能的，如果使用不当，会造成严重的后果，下面记录一个工作中遇到的实例。 二、数据丢了之前项目中为了实现Service保活，使用了多进程的方式，Service开了一个新的进程，程序里面很多配置信息都是用的SharedPreferences实现的，并且读写操作都有。通过查看google官方文档可以知道，SharedPreferences提供了跨进程的模式MODE_MULTI_PROCESS This constant was deprecated in API level 23.MODE_MULTI_PROCESS does not work reliably in some versions of Android, and furthermore does not provide any mechanism for reconciling concurrent modifications across processes. Applications should not attempt to use it. Instead, they should use an explicit cross-process data management approach such as ContentProvider. 官方文档里面这种跨进程方式在某些Android版本上不可靠，并且未来也不会提供任何支持，要是用跨进程数据传输需要使用类似ContentProvider的东西。考虑到当时使用Android6.0的设备占比很低，而且由于项目里面很多地方都使用了SharedPreferences，换一种方案代价会比较大，最终还是抱着试试的态度直接通过设置MODE_MULTI_PROCESS这种模式在多进程里面使用SharedPreferences读写数据了。 然而，结果很悲催，测试发现时不时就会出现数据丢失的情况。无果，只能看源码了 三、神奇的mode在上面的实例中，使用了MODE_MULTI_PROCESS这种模式来操作SharedPreferences，结果发现多进程中出现了数据丢失的情况，说明在多进程中，SharedPreferences的MODE_MULTI_PROCESS并不能实现进程安全。既然如此，看下MODE_MULTI_PROCESS到底做了什么。Context是一个抽象类，其实现是ContextImpl，去到ContextImpl类里面的getSharedPreference方法 public SharedPreferences getSharedPreferences(File file, int mode) { checkMode(mode); SharedPreferencesImpl sp; synchronized (ContextImpl.class) { final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked(); sp = cache.get(file); if (sp == null) { sp = new SharedPreferencesImpl(file, mode); cache.put(file, sp); return sp; } } if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) { // If somebody else (some other process) changed the prefs // file behind our back, we reload it. This has been the // historical (if undocumented) behavior. sp.startReloadIfChangedUnexpectedly(); } return sp; } 再去到SharedPreferencesImpl里面 void startReloadIfChangedUnexpectedly() { synchronized (this) { // TODO: wait for any pending writes to disk? if (!hasFileChangedUnexpectedly()) { return; } startLoadFromDisk(); } } private void startLoadFromDisk() { synchronized (this) { mLoaded = false; } new Thread(&quot;SharedPreferencesImpl-load&quot;) { public void run() { loadFromDisk(); } }.start(); } 通过源码可以看到这个mode用于API11以前的系统上，次获取这个sp的时候，如果有这个mode，会重新读一遍文件，而且后续读取过程并没有再用到MODE_MULTI_PROCESS这个mode。所以，如果这个mode并没有用来处理进程安全，如果多进程中使用，必然是会出现上面实例中的时不时丢数据的情况。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化（一）之常用工具]]></title>
      <url>%2F2017%2F06%2F04%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[Android性能优化相关的开发工具有很多很多种，这里对如下六个工具做个简单的使用介绍，主要有： Android开发者选项 分析具体耗时的Trace view 布局复杂度工具Hierarchy View 应用启动时间 Memory、CPU、Network分析 静态代码检查工具Lint 程序稳定性monkey 一、Android开发者选项Andorid手机自带的开发者选项： Take bug report（进行漏洞报告）: 点击这个选项会获取当前设备的log信息文件，打包并准备发送我们想要发送的人。这会花费1、2分钟，然后会看到一个准备好的提示信息，然后可以点击发送。 Desktop backup password（桌面备份密码）：可以使用adb备份和存储app和他们的关联数据到你的电脑。这个选项强制需要一个密码备份和存储。 Stay awake（保持唤醒）：选中这个复选框会强制屏幕唤醒，只要连接上usb线或者充电的时候都会不进入休眠，当需要调试的时候不用老是去解锁了，相当方便。 Select runtime（选择运行时）：你可以选择Dalvik或者ART。ART仍然是实验性的，直到Android L才最终release。 Enable Bluetooth HCI snoop log（蓝牙HCI搜索日志）：有时，开发者需要获取和分析蓝牙的HCI包，使能这个会在设备storage（路径为：/sdcard/btsnoop_hco.log）中保存包的信息。接着你可以使用类似wireshark等软件分析。 Process stats（程序状态）：你需要知道的所有运行在手机上的程序的任何信息。包括了ram使用量，运行时间等。 USB debugging（USB调试）：USB调试时使用，使用DDMS和ADB命令的时候也需要这个使能，不勾选这个就不能调试我们的应用了。 Revoke USB debugging authorizations（撤回USB除错授权）：当第一次USB线连接电脑的时候，需要认证并且建立密钥，这个操作删除这个认证，强制重新来一遍。 Power menu bug reports（电源菜单中包括漏洞报告）：在电源菜单中包括用于进行漏洞报告的选项。 Allow mock locations（允许虚拟位置）：允许手动写入位置信息，对于需要模拟位置的应用来说十分方便，可以干一些坏事，你懂得。 Select debug app（选择待调试的应用程序）：这个设置让你选择一个待调试的应用。 Wait for debugger（等待调试程序）：等待调试程序 Show touches（显示触摸位置）：显示触摸的位置，一般是一个小圈圈。 Pointer location（显示指针位置）：显示出当前位置的坐标。 Show surface updates（显示屏幕更新）：屏幕更新时会闪烁。 Show layout bounds（显示布局边界）：显示剪切边界、边缘。 Force RTL layout direction（强制RTL布局）：界面布局从右至左。 Window animation scale（窗口动画比例）：窗口动画的比例，数字越小，速度越快。 Transition animation scale（过渡动画比例）：过渡动画的比例，同上。 Simulate secondary displays（模拟二级显示）：允许开发者模拟不同尺寸的表现。 Force GPU rendering（强制GPU渲染）：强制应用使用硬件2D渲染除非应用本身不需要。 Show GPU view updates（显示GPU视图更新）：任何用硬件GPU来绘制视图的会有红色的覆盖层。 Show hardware layer updates（显示硬件层更新）：这个设置会告诉你什么时候硬件层在更新。 Debug GPU overdraw（调试GPU过度渲染）：过度渲染发生在任何时候当应用请求系统绘制一些视图在其他视图之上的时候。 Force 4x MSAA（启动4x MSAA）：这个设置强制多重采样抗锯齿。MSAA就是寻找出物体边缘部分的像素，然后再把画缩放到当前的显示器上。会降低性能提升视觉的美感。 Strict mode enabled（严格模式）：应用程序在主线程上执行长时间操作屏幕会闪烁。 Show CPU usage（显示CPU使用情况）：在屏幕右上角显示当前CPU的信息。 Profile GPU rendering（GPU显示配置文件）：这个设置可以在屏幕上显示也可以写入到文件中。 Enable OpenGL traces（启动OpenGL跟踪）：这个设置是观察OpenGL的错误，并把log保存到文件中。 Don’t keep activities（不保留活动）：用户离开后立即清理每个活动。 Background process limit（限制后台进程）：允许当前后台运行多少个进程的一个选择。 Show all ANRs（显示全部ANR）：当应用有bug的时候回显示应用无响应对话框。 二、应用具体耗时工具Trace viewTrace view用于查找程序运行时具体耗时在哪，它显示两个面板，一个是Timeline面板，描述每一个线程和方法启动和结束的时间。另一个是Profile面板，提供一个所有方法内部发生了什么的概要。 先新建工程PerformanceTool，然后新建布局main_activity_layout.xml，一个按钮用来加载一个网页；另一个页面就是一个webview。然后编写代码，首先是MainActivity.java: public class MainActivity extends AppCompatActivity { private Button mBtnOpenWevView = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); } private void initView() { mBtnOpenWevView = (Button) findViewById(R.id.button); mBtnOpenWevView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this , WebViewActivity.class); startActivity(intent); } }); } } 接着是WebviewActivity.java： public class WebViewActivity extends AppCompatActivity { private WebView mWebView = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_webview); //Debug.startMethodTracing(&quot;perform&quot;); initView(); //Debug.stopMethodTracing(); } private void initView() { mWebView = (WebView) findViewById(R.id.mWebView); mWebView.loadUrl(&quot;http://www.baidu.com&quot;); mWebView.setWebViewClient(new WebViewClient(){ @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { view.loadUrl(url); return true; } }); } @Override protected void onDestroy() { super.onDestroy(); mWebView = null; } } view形式traceview有两种使用方法，一种是直接通过DDMS工具来start和stop trace，使用方法如下：接着运行程序，成功运行后 点击菜单栏的Tools -&gt; Android -&gt; Android Device Monitor ： 进入Monitor之后，点击DDMS,这个时候在monitor的左边面板会出现当前设备上的包名列表 点击对应要trace的包名，然后点击Stop左边的有个小红点的按钮点击ok之后便开始执行trace了，这个时候再点击那个app里面的加载网页的按钮，加载完后，再次点击那个STOP左边那个变成小黑点的按钮。 接着便trace完成了，就可以查看如下两个面板了。上图就是Timeline面板，左边就是每行都是显示一个线程，右边对应它的时间线。可以看出来主要就是main线程在做事情。上图就是Profile面板，首先是左边的name，比如序号为14，这里展开有Parents和Children，其中Parents就是调用该方法的方法，这里onCreate在performCreate中被调用，Children就是该方法内部调用的方法，这里调用了loadUrl。与项目中的真实的代码完全相符。接着看下右边一排的Incl Cpu Time、Excl Cpu Time、Incl Real Time、Excl Real Time、Call+Recur Calls/Total、Cpu Time/Call、Real Time/Call。 Incl Cpu Time：某方法占用CPU的时间，包含内部调用其他方法占用CPU的时间。 Excl Cpu Time：某方法占用CPU的时间，不包含内部调用其他方法所占用的CPU时间。 Incl Real Time：某方法运行的真实的时间（单位ms），包含内部调用其他方法所占用的真实时间。 Excl Real Time：某方法运行的真实的时间（单位ms），不包含内部调用其他方法所占用的真实时间。 Call+Recur Calls/Total：某方法被调用的次数以及递归调用占总调用次数的百分比。 Cpu Time/Call：某方法占用CPU的时间和次数的比例。 Cpu Time/Call：某方法占用CPI真实时间和调用次数的比例。 代码形式 另一种是通过注入代码来实现： 在WebviewActivity的onCreate代码中加入两行代码如下： @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_webview); Debug.startMethodTracing(&quot;perform&quot;); initView(); Debug.stopMethodTracing(); } 别忘了加上SD卡的读写权限，然后运行app，点击加载网页按钮，就会在/sdcard目录下生产perform.trace文件，通过adb pull可以把文件导出来。 adb pull /sdcard/perform.trace Downloads/ 这里导出到了Downloads目录下，然后通过AndroidMonitor的file-&gt;open file选择这个文件打开：然后就可以查看分析了。通过代码的好处就是比较精确的得到我们想要测试的，不过代价就是要写代码编译，导出来，步骤相对来说比较繁琐。而直接使用工具的话只是一个大概的范围，但是方便快捷。可以视情况使用其中之一。 三、布局复杂度工具Hierarchy ViewHierarchy View主要是检测布局复杂度，各视图的布局耗时情况的一个工具，它需要在模拟器上进行，真机好像也有方法解决，不过很懒没去折腾，主要还是学习工具为主嘛。 点击菜单Tools -&gt; Android -&gt; Android Device Monitor： 然后进入到Android Device Monitor，选中Hierarchy View选中后会出现层级树然后我们点击那个加载网页的button，可以看到对应的加载耗时，分别有Measure，Layout和Draw的耗时。 我们可以根据其耗时来优化我们界面。 四、应用启动时间一般我们都会比较关注一个app启动的时间，如果启动太慢了，用户可能就不想玩了，这里有个方法可以测试应用启动的时间：命令行如下： adb shell am start -W packagename/activity 这里举个例子，比如说是上述项目中的PerformaceDemo app，那么首先打开终端，连接上usb线，然后终端输入: adb shell am start -W com.performance.demo/.MainActivity 等待会儿，app会启动，并且输出如下所示信息： Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER]cmp=com.performance.demo/.MainActivity } Status: ok Activity: com.performance.demo/.MainActivity ThisTime: 791 TotalTime: 791 WaitTime: 808 Complete 如上所示可以看出用时791ms。 五、Memory、CPU、Network很多时候我们需要了解app的内存使用情况，CPU占用怎样，网络速度如何。为了提高性能，我们总是想把内存减少到最小，CPU占用率近可能小，网络情况适宜。当然这些可以用命令行实现，毕竟androd基于linux操作系统的，但是那样显得很麻烦又不是很直观，很庆幸Android Studio自带了功能。Android Studio的Android Monitor里面有logcat和Monitors，选中monitors就有对于Memory，CPU和Network的展示。如下图所示： 这里展示了Memory的使用量，CPU的占用量，以及网络的速度。上图就是点击了加载网页时候的一个分布情况。它可以帮我们查看并优化我们的程序，从而显得非常的直观。 六、 静态代码检查工具LintLint主要是提供一套静态代码分析的工具，它可以帮助我们检查项目中存在的问题，让我们更有规范性的开发App。运行菜单的analyze-&gt;Inspect Code 稍息片刻系统就会分析完成，如下所示： Lint分很多子项。Internationalization国际化问题，硬编码的文字都是需要添加进@string资源，Security安全性问题，Usability可用性问题，未使用到资源、资源缺少的问题等等，具体可以根据分析后的结果来一步步改善。 七、程序稳定性：monkey通过monkey对程序在提交测试前做自测，可以检测出明显的导致程序不稳定的问题，执行monkey只需要一行命令，提交测试前跑一次可以避免应用刚提交就被打回的问题。 adb shell monkey -p com.performance.demo -v 500 -p表示包名，-v表示反馈级别 500就是500个伪随机事件若在压力测试中程序崩溃或者接收到任何失控异常，就会自动停止。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android插件化（二）之调用外部dex文件中的代码]]></title>
      <url>%2F2017%2F05%2F27%2FAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8dex%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[Java程序中，JVM虚拟机是通过类加载器ClassLoader加载.jar文件里面的类的。Android也类似，不过Android用的是Dalvik/ART虚拟机，不是JVM，也不能直接加载.jar文件，而是加载dex文件。 先要通过Android SDK提供的DX工具把.jar文件优化成.dex文件，然后Android的虚拟机才能加载。注意，有的Android应用能直接加载.jar文件，那是因为这个.jar文件已经经过优化，只不过后缀名没改（其实已经是.dex文件）。 一、jar文件优化成.dex文件首先我们可以通过JDK的编译命令javac把Java代码编译成.class文件，再使用jar命令把.class文件封装成.jar文件，这与编译普通Java程序的时候完全一样。之后再用Android SDK的DX工具把.jar文件优化成.dex文件（在“android-sdk\build-tools\具体版本\”路径下） dx --dex --output=target.dex origin.jar // target.dex就是我们要的了 此外，我们可以现把代码编译成APK文件，再把APK里面的.dex文件解压出来，或者直接把APK文件当成.dex使用（只是APK里面的静态资源文件我们暂时还用不到）。至此我们发现，无论加载.jar，还是.apk，其实都和加载.dex是等价的，Android能加载.jar和.apk，是因为它们都包含有.dex，直接加载.apk文件时，ClassLoader也会自动把.apk里的.dex解压出来。 二、加载并调用.dex里面的方法与JVM不同，Android的虚拟机不能用ClassCload直接加载.dex，而是要用DexClassLoader或者PathClassLoader,他们都是ClassLoader的子类，这两者的区别是1) DexClassLoader：可以加载jar/apk/dex，可以从SD卡中加载未安装的apk；2) PathClassLoader：要传入系统中apk的存放Path，所以只能加载已经安装的apk文件；使用前，先看看DexClassLoader的构造方法 public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) { super((String) null, (File) null, (String) null, (ClassLoader) null); throw new RuntimeException(&quot;Stub!&quot;); } 注意，我们之前提到的，DexClassLoader并不能直接加载外部存储的.dex文件，而是要先拷贝到内部存储里。这里的dexPath就是.dex的外部存储路径，而optimizedDirectory则是内部路径，libraryPath用null即可，parent则是要传入当前应用的ClassLoader，这与ClassLoader的“双亲代理模式”有关。 File optimizedDexOutputPath = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + &quot;test_dexloader.jar&quot;);// 外部路径 File dexOutputDir = this.getDir(&quot;dex&quot;, 0);// 无法直接从外部路径加载.dex文件，需要指定APP内部路径作为缓存目录（.dex文件会被解压到此目录） DexClassLoader dexClassLoader = new DexClassLoader(optimizedDexOutputPath.getAbsolutePath(), dexOutputDir.getAbsolutePath(), null, getClassLoader()); 到这里，我们已经成功把.dex文件给加载进来了，接下来就是如何调用.dex里面的代码，主要有两种方式。 三、如何调用.dex里面的代码使用反射的方式 使用DexClassLoader加载进来的类，我们本地并没有这些类的源码，所以无法直接调用，不过可以通过反射的方法调用，简单粗暴。 DexClassLoader dexClassLoader = new DexClassLoader(optimizedDexOutputPath.getAbsolutePath(), dexOutputDir.getAbsolutePath(), null, getClassLoader()); Class libProviderClazz = null; try{ libProviderClazz=dexClassLoader.loadClass(&quot;com.dexclassloader.MyLoader&quot;); // 遍历类里所有方法 Method[]methods=libProviderClazz.getDeclaredMethods(); for(int i=0;i&lt;methods.length;i++){ Log.e(TAG,methods[i].toString()); } Method start=libProviderClazz.getDeclaredMethod(&quot;func&quot;);// 获取方法 start.setAccessible(true);// 把方法设为public，让外部可以调用 String string=(String)start.invoke(libProviderClazz.newInstance());// 调用方法并获取返回值 Toast.makeText(this,string,Toast.LENGTH_LONG).show(); }catch(Exception exception){ // Handle exception gracefully here. exception.printStackTrace(); } 使用接口的方式毕竟.dex文件也是我们自己维护的，所以可以把方法抽象成公共接口，把这些接口也复制到主项目里面去，就可以通过这些接口调用动态加载得到的实例的方法了。 pulic interface IFunc{ public String func(); } // 调用 IFunc ifunc = (IFunc)libProviderClazz; String string = ifunc.func(); Toast.makeText(this, string, Toast.LENGTH_LONG).show(); 到这里，我们已经成功从外部路径动态加载一个.dex文件，并执行里面的代码逻辑了。通过从服务器下载最新的.dex文件并替换本地的旧文件，就能初步实现“APP的动态升级了”。 虽然我们已经能调用插件的方法了，但是还有如下问题 无法使用res目录下的资源，特别是使用XML布局，以及无法通过res资源到达自适应无法动态加载新的Activity等组件，因为这些组件需要在Manifest中注册，动态加载无法更改当前APK的Manifest这些问题的解决方案，将在以后的博客进行说明。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android插件化（一）之谈谈ClassLoader]]></title>
      <url>%2F2017%2F05%2F21%2FAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E8%B0%88%E8%B0%88ClassLoader%2F</url>
      <content type="text"><![CDATA[一、什么是ClassLoader?Java程序是由若干.class文件组成，程序运行在虚拟机上时，会调用该程序的入口函数来调用系统的相关功能，而这些功能都被封装在不同的.class文件中。虚拟机根据程序的需要，通过Java的类加载机制来动态加载某个class文件到内存当中，只有class文件被载入到了内存之后，才能被其它class所引用，而完成这一个加载工作的角色就是ClassLoader。 二、Android中的ClassLoader@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); ClassLoader classLoader = getClassLoader(); if (classLoader != null) { Log.i(TAG, &quot;onCreate classLoader &quot; + i + &quot; : &quot; + classLoader.toString()); while (classLoader.getParent() != null) { classLoader = classLoader.getParent(); i = i + 1; Log.i(TAG, &quot;onCreate classLoader &quot; + i + &quot; : &quot; + classLoader.toString()); } } } 可以看见有2个Classloader实例，一个是BootClassLoader，另一个是PathClassLoader,由此也可以看出，一个运行的Android应用至少有2个ClassLoader。查看官方文档我们可以知道Android中类加载器有BootClassLoader,URLClassLoader,PathClassLoader,DexClassLoader,BaseDexClassLoader 等都最终继承自java.lang.ClassLoader。 三、使用ClassLoader加载类在前面我们看到，Android程序启动过程中，会有一个dalvik.system.PathClassLoader,查看官方文档PathClassLoader,可以得知，PathClassLoader是ClassLoader的一个简单实现，主要用于加载系统类和加载应用中的类。 查看父类BaseDexClassLoader可以看到ClassLoader还有一个实现：DexClassLoader,通过官方文档可以得知，DexClassLoader加载.jar或者apk里面的class.dex文件，可以用于加载未安装的代码。而我们研究动态加载的目的主要是用于插件化或者热更新功能，加载的代码必然也是未安装的，所以我们要用的就是DexClassLoader。 实例化DexClassLoader首先我们看下DexClassLoader的构造函数 public class DexClassLoader extends BaseDexClassLoader { public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) {super(dexPath, new File(optimizedDirectory), libraryPath, parent); } }参数详解：dexPath：dex文件路径列表，多个路径使用”:”分隔optimizedDirectory：经过优化的dex文件输出目录，必须是应用私有目录libraryPath：动态库路径（将被添加到app动态库搜索路径列表中）parent：现有的ClassLoader实例，这个参数的主要作用是保留java中ClassLoader的双亲代理模型（优先父类加载器加载classes，由上而下的加载机制，防止重复加载类字节码） loadClassJVM中ClassLoader通过defineClass方法加载jar里面的Class，而Android中这个方法被弃用了。 @Deprecated protected final Class&lt;?&gt; defineClass(byte[] classRep, int offset, int length) throws ClassFormatError { throw new UnsupportedOperationException(“can’t load this type of class file”); }DexClassLoader中使用loadClass方法 public Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException { return loadClass(className, false); } protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException { Class&lt;?&gt; clazz = findLoadedClass(className); if (clazz == null) { ClassNotFoundException suppressed = null; try { clazz = parent.loadClass(className, false); } catch (ClassNotFoundException e) { suppressed = e; } if (clazz == null) { try { clazz = findClass(className); } catch (ClassNotFoundException e) { e.addSuppressed(suppressed); throw e; } } } return clazz;从源码中我们也可以看出，loadClass方法在加载一个类的实例的时候1) 会先查询当前ClassLoader实例是否加载过此类，有就返回； 2) 如果没有。查询Parent是否已经加载过此类，如果已经加载过，就直接返回Parent加载的类； 3) 如果继承路线上的ClassLoader都没有加载，才由Child执行类的加载工作； 这样做有个明显的特点，如果一个类被位于树根的ClassLoader加载过，那么在以后整个系统的生命周期内，这个类永远不会被重新加载。也就是双亲代理模型体现。 四、结束语通过上面的分析，我们知道使用ClassLoader动态加载一个外部的类是非常容易的事情，所以很容易就能实现动态加载新的可执行代码的功能，但是比起一般的Java程序，在Android程序中使用动态加载主要有两个麻烦的问题： 1) Android中许多组件类（如Activity、Service等）是需要在Manifest文件里面注册后才能工作的（系统会检查该组件有没有注册），所以即使动态加载了一个新的组件类进来，没有注册的话还是无法工作； 2) Res资源是Android开发中经常用到的，而Android是把这些资源用对应的R.id注册好，运行时通过这些ID从Resource实例中获取对应的资源。如果是运行时动态加载进来的新类，那类里面用到R.id的地方将会抛出找不到资源或者用错资源的异常，因为新类的资源ID根本和现有的Resource实例中保存的资源ID对不上。这两个问题，将在后续章节讲解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android系统版本差异及注意事项]]></title>
      <url>%2F2017%2F04%2F23%2FAndroid%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[一、Android 7.0 Nougat 分屏，实现多任务管理。用户可以一次在屏幕上打开两个应用。 在手机上，两个应用可以在“分屏”模式中左右并排或上下并排显示。 在电视设备上，应用可以使用“画中画”模式，在用户与另一个应用交互的同时继续播放视频。 通知栏快捷回复。实时通信应用，Android 系统支持内联回复，以便用户可以直接在通知界面中快速回复短信 引入全新的JIT编译器，使得App安装速度快了75%，编译代码的规模减少了50% 移除三项广播：CONNECTIVITY_ACTION（监听网络变化）、ACTION_NEW_PICTURE 和ACTION_NEW_VIDEO（监听相机） 新增省流量模式 支持VR 支持分屏如果您的应用面向 Android N，您可以对应用的 Activity 是否支持多窗口显示以及显示方式进行配置。官方文档有详细的处理流程。 多窗口模式不会更改 Activity 生命周期在多窗口模式中，在指定时间只有最近与用户交互过的 Activity 为活动状态。 该 Activity 将被视为顶级 Activity。 所有其他 Activity 虽然可见，但均处于暂停状态。 但是，这些已暂停但可见的 Activity 在系统中享有比不可见 Activity 更高的优先级。 如果用户与其中一个暂停的 Activity 交互，该 Activity 将恢复，而之前的顶级 Activity 将暂停。 启用或禁用多窗口显示在AndroidMainfest.xml文件的 或 节点中设置该属性 android:resizeableActivity=[“true” | “false”] 如果该属性设置为 true，Activity 将能以分屏和自由形状模式启动。 如果此属性设置为 false，Activity 将不支持多窗口模式。 如果该值为 false，且用户尝试在多窗口模式下启动 Activity，该 Activity 将全屏显示。 如果您的应用的targetVersion为24，但未对该属性指定值，则该属性的值默认设为 true。 支持画中画显示在清单文件的 节点中设置该属性，指明 Activity 是否支持画中画显示。 如果 android:resizeableActivity 为 false，将忽略该属性。 android:supportsPictureInPicture=[“true” | “false”] 分屏和自由形状模式中 Activity 的最小高度和最小宽度android:minimalHeight、android:minimalWidth例如，以下节点显示了如何指定 Activity 在自由形状模式中显示时 Activity 的默认大小、位置和最小尺寸： 二、Android 6.0 Marshmallow 运行时权限当应用的targetVersion设置为23时，在运行时需要检查和请求危险权限。checkSelfPermission() 方法用于验证用户是否授予权限；requestPermissions() 方法用于向用户请求权限。 低电耗模式和应用待机模式低电耗模式：如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。应用待机模式：应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业。 移除对Apache HTTP client的支持建议使用HttpURLConnection。如果还是想用Apache HTTP client，那么需要在build.gradle中添加 android { useLibrary &apos;org.apache.http.legacy&apos; } 移除了 Notification.setLatestEventInfo() 方法。构建通知用 Notification.Builder 类 文本选择当用户在应用中选择文本时，可以在一个浮动工具栏中显示“剪切”、“复制”和“粘贴”等文本选择操作。 三、Android 5.0 Lollipop Material designMaterial design算是Android 系统风格的里程碑，其3D UI风格新颖，贴近人机交互； 改善通知栏，提升可视化、亲近性、可编辑性。同时支持手机在锁屏状态也可接收到通知，用户可以在锁屏状态下，设置接收全部应用的通知或者接收部分应用的通知或者不接收所有应用的通知； ART（Android Runtime）运行时取代 Dalvik 成为平台默认设置，实现ahead-of-time (AOT)静态编译与just-in-time (JIT)动态编译交互进行； V7中引入CardView和RecycleView等新控件； 开放屏幕采集API通过MediaProjection屏幕采集API，可以实现录屏功能。 新增 JobScheduler APIJobScheduler API允许推迟或指定条件下（如设备充电或连入 WLAN 时）创建执行在后台的任务。 Context.bindService() 方法现在需要显式 Intent，如果提供隐式 intent，将引发异常。为确保应用的安全性，请使用显式 intent 启动或绑定 Service，且不要为服务声明 intent 过滤器。 新安装和更新需要验证自定义权限如果应用定义了一个已安装应用定义的自定义权限，且应用没有使用与该已安装应用相同的签名密钥，则系统不会重新安装应用。 支持64位系统； 处理 Intent在触发任何 intent 之前检查是否至少有一个适合此 intent 的处理程序。要检查是否存在有效的处理程序，可以调用 Intent.resolveActivity()，避免导致 ActivityNotFoundException。 电池使用情况统计新增的 dumpsys batterystats 命令可生成电池使用情况统计信息，通过它了解整个系统的耗电情况，以及了解应用对设备电池的影响。可以查看耗电事件历史记录、每个 UID 和系统组件的近似耗电情况以及其他信息。 新增了“电池耗电历史”工具，可将来自 dumpsys batterystats 的统计数据转换成可视化格式，以便进行与电池有关的调试。 启用TLSv1.2 和 TLSv1.1 协议某些服务器使用了TLSv1.2，使用WebView打开时，5.0以下的设备页面无法正常打开。 使用Material design 设置应用的 targetSdkVersion 和 targetSdkVersion 为21 在values目录下的style资源文件中创建一个style，让其继承自 android:Theme.Material 在AndroidManifest中指定应用的主题或者Activity的主题为我们设定的样式 谷歌官方我们提供了三种配色风格的Material Design样式：黑色主题 Theme.Material明亮主题 Theme.Material.Light明亮主题黑色ActionBar Theme.Material.Light.DarkActionBar 四、Android 4.4 KitKat 通过主机卡模拟实现新的 NFC 功能 打印框架Android 应用可以通过 WLAN 或云托管服务（例如 Google 云打印）打印任何类型的内容。在支持打印的应用中，用户可以发现可用的打印机，更改纸张尺寸，选择要打印的特定页面，打印几乎任何种类的文档、图像或文件。 步测器和计步器可以在用户行走、跑步或攀爬楼梯时跟踪步数。 全屏沉浸模式系统 UI 保持隐藏状态，在沉浸模式中，从屏幕顶部或底部边缘滑动手指可以显示系统 UI。 Chromium WebView支持使用 Chrome DevTools 进行远程调试。例如，可以在开发机器上使用 Chrome DevTools 检测、调试和分析移动设备中存储的 WebView 内容。 屏幕录制使用命令 adb shell screenrecord 或者通过 Android Studio 中的 DDMS 分析设备内存状态Settings &gt; Developer options &gt; Process stats 五、Android 4.X Jelly Bean UiAutomation自动化UI测试]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android琐碎知识]]></title>
      <url>%2F2017%2F04%2F15%2FAndroid%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[1.一个App有多少个Context应用程序创建Context实例的情况有如下几种情况： 创建Application 对象时， 而且整个App共一个Application对象 创建Service对象时 创建Activity对象时 因此应用程序App共有的Context数目公式为： 总Context实例个数 = Service个数 + Activity个数 + 1（Application对应的Context实例） 2.getApplication 和getApplicationContext有什么区别相同点二者使用结果相同，我们写个代码分别打印二者返回结果，发现两个方法获取的是同一个对象。 public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Application application = getApplication(); Log.i(&quot;WY&quot;, &quot;打印getApplication：&quot; + application); Context pContext = getApplicationContext(); Log.i(&quot;WY&quot;, &quot;打印getApplicationContext：&quot; + pContext); } } 不同点 getApplication()是用来获取Application实例的，getApplicationContext是用来获取Application的上下文。 getApplication只在Activity和Service中才能调用 在BroadcastReceiver中获取Application实例，需要使用getApplicationContext()方法 3.设置configChanges避免横竖屏切换Activity重建//当minSsdkVersion 和 targetSdkVersion高于13时，需要增加screenSize android：configChanges=&quot;oriention | screenSize&quot; 4.Android中的多进程 进程名以“：”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中 进程名不以“：”开头的进程属于全局进程，其他应用可以通过ShareUID方式和它跑在同一个进程中。（需要这两个应用有相同的ShareUID并且签名相同） 多进程存在的问题 （1）静态成员和单例模式完全失效；（2）线程同步机制完全失效；（3）SharedPreferences的可靠性下降；（4）Application会多次创建。 4.序列化Serializable1.serialVersionUID作用序列化的时候系统会把当前类的serialVersionUID写入序列化文件中，当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明当前类的和序列化的类相比发生了某些变换，比如成员变量的数量、类型可能发生了变换，这个时候是无法正常反序列化的，并且会报错java.io.InvalidClassException.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio调试技巧]]></title>
      <url>%2F2017%2F04%2F09%2FAndroid%20Studio%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[一、简单调试 step over：一步步往下走。点击单步调试按钮或按快捷键F8 step into：看到方法往里走。点击进入方法或按快捷键F7 force step into :所有方法看完整,可以看到你所调用的所有方法的实现会让你跟着它走一遍，研究源码使用非常方便 step out ：有断点下一个，走完断点继续走 run to Cursor ：下个断点我们见]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈Android MVP模式]]></title>
      <url>%2F2017%2F04%2F01%2F%E8%B0%88%E8%B0%88Android%20MVP%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[按照MVC的分层，Activity和Fragment（后面只说Activity）应该属于View层，用于展示UI界面，以及接收用户的输入，此外还要承担一些生命周期的工作。Activity是在Android开发中充当非常重要的角色，特别是TA的生命周期的功能，所以开发的时候我们经常把一些业务逻辑直接写在Activity里面，这非常直观方便，代价就是Activity会越来越臃肿，超过1000行代码是常有的事，而且如果是一些可以通用的业务逻辑（比如用户登录），写在具体的Activity里就意味着这个逻辑不能复用了。如果有进行代码重构经验的人，看到1000+行的类肯定会有所顾虑。因此，Activity不仅承担了View的角色，还承担了一部分的Controller角色，这样一来V和C就耦合在一起了，虽然这样写方便，但是如果业务调整的话，要维护起来就难了，而且在一个臃肿的Activity类查找业务逻辑的代码也会非常蛋疼，所以看起来有必要在Activity中，把View和Controller抽离开来，而这就是MVP模式的工作了。 MVP模式的核心思想： MVP把Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成Presenter接口，Model类还是原来的Model。 这就是MVP模式，现在这样的话，Activity的工作的简单了，只用来响应生命周期，其他工作都丢到Presenter中去完成。从上图可以看出，Presenter是Model和View之间的桥梁，为了让结构变得更加简单，View并不能直接对Model进行操作，这也是MVP与MVC最大的不同之处。 MVP模式的作用 分离了视图逻辑和业务逻辑，降低了耦合 Activity只处理生命周期的任务，代码变得更加简洁 视图逻辑和业务逻辑分别抽象到了View和Presenter的接口中去，提高代码的可阅读性 Presenter被抽象成接口，可以有多种具体的实现，所以方便进行单元测试 把业务逻辑抽到Presenter中去，避免后台线程引用着Activity导致Activity的资源无法被系统回收从而引起内存泄露和OOM 其中最重要的有三点： Activity 代码变得更加简洁相信很多人阅读代码的时候，都是从Activity开始的，对着一个1000+行代码的Activity，看了都觉得难受。使用MVP之后，Activity就能瘦身许多了，基本上只有FindView、SetListener以及Init的代码。其他的就是对Presenter的调用，还有对View接口的实现。这种情形下阅读代码就容易多了，而且你只要看Presenter的接口，就能明白这个模块都有哪些业务，很快就能定位到具体代码。Activity变得容易看懂，容易维护，以后要调整业务、删减功能也就变得简单许多。 方便进行单元测试一般单元测试都是用来测试某些新加的业务逻辑有没有问题，如果采用传统的代码风格（习惯性上叫做MV模式，少了P），我们可能要先在Activity里写一段测试代码，测试完了再把测试代码删掉换成正式代码，这时如果发现业务有问题又得换回测试代码，咦，测试代码已经删掉了！好吧重新写吧……MVP中，由于业务逻辑都在Presenter里，我们完全可以写一个PresenterTest的实现类继承Presenter的接口，现在只要在Activity里把Presenter的创建换成PresenterTest，就能进行单元测试了，测试完再换回来即可。万一发现还得进行测试，那就再换成PresenterTest吧。 避免 Activity 的内存泄露Android APP 发生OOM的最大原因就是出现内存泄露造成APP的内存不够用，而造成内存泄露的两大原因之一就是Activity泄露（Activity Leak）（另一个原因是Bitmap泄露（Bitmap Leak））。Java一个强大的功能就是其虚拟机的内存回收机制，这个功能使得Java用户在设计代码的时候，不用像C++用户那样考虑对象的回收问题。然而，Java用户总是喜欢随便写一大堆对象，然后幻想着虚拟机能帮他们处理好内存的回收工作。可是虚拟机在回收内存的时候，只会回收那些没有被引用的对象，被引用着的对象因为还可能会被调用，所以不能回收。Activity是有生命周期的，用户随时可能切换Activity，当APP的内存不够用的时候，系统会回收处于后台的Activity的资源以避免OOM。采用传统的MV模式，一大堆异步任务和对UI的操作都放在Activity里面，比如你可能从网络下载一张图片，在下载成功的回调里把图片加载到 Activity 的 ImageView 里面，所以异步任务保留着对Activity的引用。这样一来，即使Activity已经被切换到后台（onDestroy已经执行），这些异步任务仍然保留着对Activity实例的引用，所以系统就无法回收这个Activity实例了，结果就是Activity Leak。Android的组件中，Activity对象往往是在堆（Java Heap）里占最多内存的，所以系统会优先回收Activity对象，如果有Activity Leak，APP很容易因为内存不够而OOM。采用MVP模式，只要在当前的Activity的onDestroy里，分离异步任务对Activity的引用，就能避免 Activity Leak。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java服务端开发环境搭建]]></title>
      <url>%2F2017%2F03%2F21%2FJava%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[0 JDK下载安装 进入源码存放目录（eg：cd /data/src） wget下载jdk，由于wget不支持重定向，所以需要添加header（eg:wget –no-cookie –header “Cookie: oraclelicense=accept-securebackup-cookie” jdk） mv 下载的jdk压缩包到 安装目录（eg：mv jdk.tar.gz /usr/local/java） 解压安装包(eg:tar zxvf jdk.tar.gz) 运行 java -version 验证是否安装成功 1 配置环境变量这里介绍两种常用的环境变量配置方法： 修改/etc/profile文件:如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。 打开环境变量配置文件（eg:vi /etc/profile） 在文件尾追加 JAVA_HOME=/usr/local/java/jdk1.8.0_121 CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME export CLASSPATH 使用source命令启用配置（eg:source /etc/profile） 修改.bashrc文件：这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别。 打开用户目录的.bashrc文件（eg:vi ~/.bashrc） 在文件尾追加 JAVA_HOME=/usr/local/java/jdk1.8.0_121 CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME export CLASSPATH 退出重新登录 2 环境测试 在任意目录，通常在/data/tmp目录新建一个java文件（eg:Demo.java） 编译代码，javac Demo.java 运行代码，java Demo 3 常见问题“Error: Could not find or load main class” 如果java代码里面没有设置package，则是环境变量配置有误； 如果java代码里面有设置package，则需要构建和包名一致的路径，eg:package com.cjh.demo,则需要构建com/cjh/demo目录，并把编译的class文件放到该目录，然后回到和com平级的目录里面运行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我和我的博客]]></title>
      <url>%2F2017%2F03%2F03%2F%E6%88%91%E5%92%8C%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[工作已经快两年了，写了很多代码，也看了很多博客，慢慢的也有了自己的感悟，所以就有了这个博客。 GitHub. 缘由我认为有两点 记录与升华。通过写博客，我们可以记录工作中的思考、生活中的点滴，技术成长的同时，也装点了我们的回忆。 分享与提升。通过写博客，促使我们去专研问题并与人分享，同时通过他人的交流反馈来改善自我、提升自我。 另一份简历。博客也是简历之一，通过博客，可以更好的向他人展示自我。这也是非常有趣的事O(∩_∩)O~~ 风格简单，直接，文艺]]></content>
    </entry>

    
  
  
</search>
