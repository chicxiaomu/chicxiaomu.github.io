<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android性能优化（二）之Monkey性能测试]]></title>
      <url>%2F2017%2F04%2F15%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8BMonkey%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[##一、Monkey简介 Android的SDK 里面，Monkey的tools是一个命令行工具，当连接Android设备时，只要在命令行里输入相应命令就能运行tools； Monkey test是一项压力测试，可以在规定的次数范围内做任何随机的操作，随机操作包括点击、滑动、Application切换、横竖屏、应用关闭等等，用户能做的操作统统可以模拟； Monkey test跑出来crash的bug等级永远为1，版本release前，Monkey跑出的结果中crash要为0。业内标准：final release前，Monkey跑完的总次数应为25W次，其结果里不允许有nullPointException出现. ##二、Monkey命令 标准命令： abd devices 列出所有的已连接的设备（包括真机和虚拟机） adb shell 进入shell模式，查看data/data文件夹中的安装包情况 [adb shell] monkey [options] 栗子：adb shell monkey -v 500 产生500次随机事件，作用与系统中所有的activity（其实也不是所有的activity，而是包含 Intent.CATEGORY_LAUNCHER 或Intent.CATEGORY_MONKEY 的activity）。 ##三、命令分类 常用选项： -help：打印帮助信息-v：指定打印信息的详细级别，一个 -v增加一个级别 ， 默认级别为 0 ,最高为-v -v -v 事件选项； -s：指定产生随机事件种子值，相同的种子值产生相同的事件序列。如： -s 200 --throttle：每个事件结束后的间隔时间——降低系统的压力（如不指定，系统会尽快的发送事件序列）。如：--throttle 100 --pct-touch：指定触摸事件的百分比，如：--pct-touch 5% 相关的还有以下option： --pct-motion &lt;percent&gt; （滑动事件） --pct-trackball &lt;percent&gt; （轨迹球事件） --pct-nav &lt;percent&gt;（导航事件 up/down/left/right） --pct-majornav &lt;percent&gt; (主要导航事件 back key 、 menu key) --pct-syskeys &lt;percent&gt; (系统按键事件 Home 、Back 、startCall 、 endCall 、 volumeControl) --pct-appswitch &lt;percent&gt; （activity之间的切换） --pct-anyevent &lt;percent&gt;（任意事件） 约束选项： -p：指定有效的package（如不指定，则对系统中所有package有效），一个-p 对应一个有效package， 如： -p com.ckt -p com.ckt.asura； -c：activity必须至少包含一个指定的category，才能被启动，否则启动不了； 调试选项： –dbg-no-events：初始化启动的activity，但是不产生任何事件。为了得到最佳结果，把它与-v、一个或几个包约 束、以及一个保持Monkey运行30秒或更长时间的非零值联合起来，从而提供一个环境，可以监视应用程序所调用的包之间的转换 --hprof：指定该项后在事件序列发送前后会立即生成分析报告 —— 一般建议指定该项。 --ignore-crashes：忽略崩溃 --ignore-timeouts：忽略超时 --ignore-security-exceptions：忽略安全异常 --kill-process-after-error：发生错误后直接杀掉进程 --monitor-native-crashes：跟踪本地方法的崩溃问题 --wait-dbg：直到连接了调试器才执行monkey测试。 ##四、栗子： adb shell monkey -p com.ssjjsy.sdk.hk.demo -s 100 --throttle 10 --ignore-crashes --ignore-timeouts --monitor-native-crashes --pct-appswitch 30 --pct-majornav 20 --pct-nav 20 --pct-touch 20 --pct-motion 10 -v -v -v 10000 &gt; E:\Git\monkey_log.txt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化（一）之常用工具]]></title>
      <url>%2F2017%2F04%2F09%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[Android性能优化相关的开发工具有很多很多种，这里对如下六个工具做个简单的使用介绍，主要有： Android开发者选项 分析具体耗时的Trace view 布局复杂度工具Hierarchy View 应用启动时间 Memory、CPU、Network分析 静态代码检查工具Lint 程序稳定性monkey ###一、Android开发者选项 Andorid手机自带的开发者选项： Take bug report（进行漏洞报告）: 点击这个选项会获取当前设备的log信息文件，打包并准备发送我们想要发送的人。这会花费1、2分钟，然后会看到一个准备好的提示信息，然后可以点击发送。 Desktop backup password（桌面备份密码）：可以使用adb备份和存储app和他们的关联数据到你的电脑。这个选项强制需要一个密码备份和存储。 Stay awake（保持唤醒）：选中这个复选框会强制屏幕唤醒，只要连接上usb线或者充电的时候都会不进入休眠，当需要调试的时候不用老是去解锁了，相当方便。 Select runtime（选择运行时）：你可以选择Dalvik或者ART。ART仍然是实验性的，直到Android L才最终release。 Enable Bluetooth HCI snoop log（蓝牙HCI搜索日志）：有时，开发者需要获取和分析蓝牙的HCI包，使能这个会在设备storage（路径为：/sdcard/btsnoop_hco.log）中保存包的信息。接着你可以使用类似wireshark等软件分析。 Process stats（程序状态）：你需要知道的所有运行在手机上的程序的任何信息。包括了ram使用量，运行时间等。 USB debugging（USB调试）：USB调试时使用，使用DDMS和ADB命令的时候也需要这个使能，不勾选这个就不能调试我们的应用了。 Revoke USB debugging authorizations（撤回USB除错授权）：当第一次USB线连接电脑的时候，需要认证并且建立密钥，这个操作删除这个认证，强制重新来一遍。 Power menu bug reports（电源菜单中包括漏洞报告）：在电源菜单中包括用于进行漏洞报告的选项。 Allow mock locations（允许虚拟位置）：允许手动写入位置信息，对于需要模拟位置的应用来说十分方便，可以干一些坏事，你懂得。 Select debug app（选择待调试的应用程序）：这个设置让你选择一个待调试的应用。 Wait for debugger（等待调试程序）：等待调试程序 Show touches（显示触摸位置）：显示触摸的位置，一般是一个小圈圈。 Pointer location（显示指针位置）：显示出当前位置的坐标。 Show surface updates（显示屏幕更新）：屏幕更新时会闪烁。 Show layout bounds（显示布局边界）：显示剪切边界、边缘。 Force RTL layout direction（强制RTL布局）：界面布局从右至左。 Window animation scale（窗口动画比例）：窗口动画的比例，数字越小，速度越快。 Transition animation scale（过渡动画比例）：过渡动画的比例，同上。 Simulate secondary displays（模拟二级显示）：允许开发者模拟不同尺寸的表现。 Force GPU rendering（强制GPU渲染）：强制应用使用硬件2D渲染除非应用本身不需要。 Show GPU view updates（显示GPU视图更新）：任何用硬件GPU来绘制视图的会有红色的覆盖层。 Show hardware layer updates（显示硬件层更新）：这个设置会告诉你什么时候硬件层在更新。 Debug GPU overdraw（调试GPU过度渲染）：过度渲染发生在任何时候当应用请求系统绘制一些视图在其他视图之上的时候。 Force 4x MSAA（启动4x MSAA）：这个设置强制多重采样抗锯齿。MSAA就是寻找出物体边缘部分的像素，然后再把画缩放到当前的显示器上。会降低性能提升视觉的美感。 Strict mode enabled（严格模式）：应用程序在主线程上执行长时间操作屏幕会闪烁。 Show CPU usage（显示CPU使用情况）：在屏幕右上角显示当前CPU的信息。 Profile GPU rendering（GPU显示配置文件）：这个设置可以在屏幕上显示也可以写入到文件中。 Enable OpenGL traces（启动OpenGL跟踪）：这个设置是观察OpenGL的错误，并把log保存到文件中。 Don’t keep activities（不保留活动）：用户离开后立即清理每个活动。 Background process limit（限制后台进程）：允许当前后台运行多少个进程的一个选择。 Show all ANRs（显示全部ANR）：当应用有bug的时候回显示应用无响应对话框。 ###二、应用具体耗时工具Trace view Trace view用于查找程序运行时具体耗时在哪，它显示两个面板，一个是Timeline面板，描述每一个线程和方法启动和结束的时间。另一个是Profile面板，提供一个所有方法内部发生了什么的概要。 先新建工程PerformanceTool，然后新建布局main_activity_layout.xml，一个按钮用来加载一个网页；另一个页面就是一个webview。然后编写代码，首先是MainActivity.java: public class MainActivity extends AppCompatActivity { private Button mBtnOpenWevView = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); } private void initView() { mBtnOpenWevView = (Button) findViewById(R.id.button); mBtnOpenWevView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this , WebViewActivity.class); startActivity(intent); } }); } } 接着是WebviewActivity.java： public class WebViewActivity extends AppCompatActivity { private WebView mWebView = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_webview); //Debug.startMethodTracing(&quot;perform&quot;); initView(); //Debug.stopMethodTracing(); } private void initView() { mWebView = (WebView) findViewById(R.id.mWebView); mWebView.loadUrl(&quot;http://www.baidu.com&quot;); mWebView.setWebViewClient(new WebViewClient(){ @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { view.loadUrl(url); return true; } }); } @Override protected void onDestroy() { super.onDestroy(); mWebView = null; } } ####view形式 traceview有两种使用方法，一种是直接通过DDMS工具来start和stop trace，使用方法如下：接着运行程序，成功运行后 点击菜单栏的Tools -&gt; Android -&gt; Android Device Monitor ： 进入Monitor之后，点击DDMS,这个时候在monitor的左边面板会出现当前设备上的包名列表 点击对应要trace的包名，然后点击Stop左边的有个小红点的按钮点击ok之后便开始执行trace了，这个时候再点击那个app里面的加载网页的按钮，加载完后，再次点击那个STOP左边那个变成小黑点的按钮。 接着便trace完成了，就可以查看如下两个面板了。上图就是Timeline面板，左边就是每行都是显示一个线程，右边对应它的时间线。可以看出来主要就是main线程在做事情。上图就是Profile面板，首先是左边的name，比如序号为14，这里展开有Parents和Children，其中Parents就是调用该方法的方法，这里onCreate在performCreate中被调用，Children就是该方法内部调用的方法，这里调用了loadUrl。与项目中的真实的代码完全相符。接着看下右边一排的Incl Cpu Time、Excl Cpu Time、Incl Real Time、Excl Real Time、Call+Recur Calls/Total、Cpu Time/Call、Real Time/Call。 Incl Cpu Time：某方法占用CPU的时间，包含内部调用其他方法占用CPU的时间。 Excl Cpu Time：某方法占用CPU的时间，不包含内部调用其他方法所占用的CPU时间。 Incl Real Time：某方法运行的真实的时间（单位ms），包含内部调用其他方法所占用的真实时间。 Excl Real Time：某方法运行的真实的时间（单位ms），不包含内部调用其他方法所占用的真实时间。 Call+Recur Calls/Total：某方法被调用的次数以及递归调用占总调用次数的百分比。 Cpu Time/Call：某方法占用CPU的时间和次数的比例。 Cpu Time/Call：某方法占用CPI真实时间和调用次数的比例。 ####代码形式 另一种是通过注入代码来实现： 在WebviewActivity的onCreate代码中加入两行代码如下： @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_webview); Debug.startMethodTracing(&quot;perform&quot;); initView(); Debug.stopMethodTracing(); } 别忘了加上SD卡的读写权限，然后运行app，点击加载网页按钮，就会在/sdcard目录下生产perform.trace文件，通过adb pull可以把文件导出来。 adb pull /sdcard/perform.trace Downloads/ 这里导出到了Downloads目录下，然后通过AndroidMonitor的file-&gt;open file选择这个文件打开：然后就可以查看分析了。通过代码的好处就是比较精确的得到我们想要测试的，不过代价就是要写代码编译，导出来，步骤相对来说比较繁琐。而直接使用工具的话只是一个大概的范围，但是方便快捷。可以视情况使用其中之一。 ###三、布局复杂度工具Hierarchy View Hierarchy View主要是检测布局复杂度，各视图的布局耗时情况的一个工具，它需要在模拟器上进行，真机好像也有方法解决，不过很懒没去折腾，主要还是学习工具为主嘛。 点击菜单Tools -&gt; Android -&gt; Android Device Monitor： 然后进入到Android Device Monitor，选中Hierarchy View选中后会出现层级树然后我们点击那个加载网页的button，可以看到对应的加载耗时，分别有Measure，Layout和Draw的耗时。 我们可以根据其耗时来优化我们界面。 ###四、应用启动时间 一般我们都会比较关注一个app启动的时间，如果启动太慢了，用户可能就不想玩了，这里有个方法可以测试应用启动的时间：命令行如下： adb shell am start -W packagename/activity 这里举个例子，比如说是上述项目中的PerformaceDemo app，那么首先打开终端，连接上usb线，然后终端输入: adb shell am start -W com.performance.demo/.MainActivity 等待会儿，app会启动，并且输出如下所示信息： Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER]cmp=com.performance.demo/.MainActivity } Status: ok Activity: com.performance.demo/.MainActivity ThisTime: 791 TotalTime: 791 WaitTime: 808 Complete 如上所示可以看出用时791ms。 ###五、Memory、CPU、Network 很多时候我们需要了解app的内存使用情况，CPU占用怎样，网络速度如何。为了提高性能，我们总是想把内存减少到最小，CPU占用率近可能小，网络情况适宜。当然这些可以用命令行实现，毕竟androd基于linux操作系统的，但是那样显得很麻烦又不是很直观，很庆幸Android Studio自带了功能。Android Studio的Android Monitor里面有logcat和Monitors，选中monitors就有对于Memory，CPU和Network的展示。如下图所示： 这里展示了Memory的使用量，CPU的占用量，以及网络的速度。上图就是点击了加载网页时候的一个分布情况。它可以帮我们查看并优化我们的程序，从而显得非常的直观。 ###六、 静态代码检查工具Lint Lint主要是提供一套静态代码分析的工具，它可以帮助我们检查项目中存在的问题，让我们更有规范性的开发App。运行菜单的analyze-&gt;Inspect Code 稍息片刻系统就会分析完成，如下所示： Lint分很多子项。Internationalization国际化问题，硬编码的文字都是需要添加进@string资源，Security安全性问题，Usability可用性问题，未使用到资源、资源缺少的问题等等，具体可以根据分析后的结果来一步步改善。 ###七、程序稳定性：monkey 通过monkey对程序在提交测试前做自测，可以检测出明显的导致程序不稳定的问题，执行monkey只需要一行命令，提交测试前跑一次可以避免应用刚提交就被打回的问题。 adb shell monkey -p com.performance.demo -v 500 -p表示包名，-v表示反馈级别 500就是500个伪随机事件若在压力测试中程序崩溃或者接收到任何失控异常，就会自动停止。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java服务端开发环境搭建]]></title>
      <url>%2F2017%2F03%2F21%2FJava%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[0 JDK下载安装 进入源码存放目录（eg：cd /data/src） wget下载jdk，由于wget不支持重定向，所以需要添加header（eg:wget –no-cookie –header “Cookie: oraclelicense=accept-securebackup-cookie” jdk） mv 下载的jdk压缩包到 安装目录（eg：mv jdk.tar.gz /usr/local/java） 解压安装包(eg:tar zxvf jdk.tar.gz) 运行 java -version 验证是否安装成功 1 配置环境变量这里介绍两种常用的环境变量配置方法： 修改/etc/profile文件:如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。 打开环境变量配置文件（eg:vi /etc/profile） 在文件尾追加 JAVA_HOME=/usr/local/java/jdk1.8.0_121 CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME export CLASSPATH 使用source命令启用配置（eg:source /etc/profile） 修改.bashrc文件：这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别。 打开用户目录的.bashrc文件（eg:vi ~/.bashrc） 在文件尾追加 JAVA_HOME=/usr/local/java/jdk1.8.0_121 CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME export CLASSPATH 退出重新登录 2 环境测试 在任意目录，通常在/data/tmp目录新建一个java文件（eg:Demo.java） 编译代码，javac Demo.java 运行代码，java Demo 3 常见问题“Error: Could not find or load main class” 如果java代码里面没有设置package，则是环境变量配置有误； 如果java代码里面有设置package，则需要构建和包名一致的路径，eg:package com.cjh.demo,则需要构建com/cjh/demo目录，并把编译的class文件放到该目录，然后回到和com平级的目录里面运行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我和我的博客]]></title>
      <url>%2F2017%2F03%2F03%2F%E6%88%91%E5%92%8C%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[工作已经快两年了，写了很多代码，也看了很多博客，慢慢的也有了自己的感悟，所以就有了这个博客。 GitHub. 缘由我认为有两点 记录与升华。通过写博客，我们可以记录工作中的思考、生活中的点滴，技术成长的同时，也装点了我们的回忆。 分享与提升。通过写博客，促使我们去专研问题并与人分享，同时通过他人的交流反馈来改善自我、提升自我。 另一份简历。博客也是简历之一，通过博客，可以更好的向他人展示自我。这也是非常有趣的事O(∩_∩)O~~ 风格简单，直接，文艺]]></content>
    </entry>

    
  
  
</search>
