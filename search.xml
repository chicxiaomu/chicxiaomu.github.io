<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android Service保活（三）之JobService]]></title>
      <url>%2F2017%2F06%2F07%2FAndroid%20Service%E4%BF%9D%E6%B4%BB%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8BJobService%2F</url>
      <content type="text"><![CDATA[在前两章中，我们系统的学习了Android Service防杀套路和双进程守护的实现，本篇博文，我将带领大家学习更高端的APP进行防杀技巧，该技巧除了能够应对卫士、管家的清杀以外，更能够在类似于某米、某为系统的清理内存软件清理下确保进程存活下来。它就是我们今天的主角JobShedulerService。通常在5.0之前，我们可以使用广播或者闹钟等方式让我们的进程防杀自启，而5.0以后的Android系统，我们就可以使用JobService，JobService它是Android5.0以后新增的一个服务，我们先来看下官方的解释。 Google从Android SDK 21之后添加了JobScheduler来执行一些满足特定条件但不紧急的后台任务，我们可以利用JobScheduler来执行这些特殊的后台任务时来减少电量的消耗。JobService则是一个抽象类，其中包含两个抽象方法： abstract boolean onStartJob(JobParameters params) // 我们需要重写onStartJob方法在JobService被调度的时候 abstract boolean onStopJob(JobParameters params) // 如果确定停止系统调度作业，即使调度作业可能被完成，将调用此方法 当我们有以下需求时，可以使用调度作业 APP有可以推迟的非面向用户的工作 APP有当插入设备时您希望优先执行的工作 APP有需要访问网络或 Wi-Fi 连接的任务 APP有希望作为一个批次定期运行的许多任务 接下来，我们使用JobService来实现APP进程防杀。 ####首先声明权限 &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt; ####自定义一个Service类，继承自JobService @SuppressLint(&quot;NewApi&quot;) public class JobCastielService extends JobService{ private int kJobId = 0; @Override public int onStartCommand(Intent intent, int flags, int startId) { Log.i(&quot;castiel&quot;, &quot;jobService启动&quot;); scheduleJob(getJobInfo()); return START_NOT_STICKY; } @Override public boolean onStartJob(JobParameters params) { Log.i(&quot;castiel&quot;, &quot;执行了onStartJob方法&quot;); boolean isLocalServiceWork = isServiceWork(this, &quot;com.castiel.service.LocalCastielService&quot;); boolean isRemoteServiceWork = isServiceWork(this, &quot;com.castiel.service.RemoteCastielService&quot;); if(!isLocalServiceWork|| !isRemoteServiceWork){ this.startService(new Intent(this,LocalCastielService.class)); this.startService(new Intent(this,RemoteCastielService.class)); Toast.makeText(this, &quot;进程启动&quot;, Toast.LENGTH_SHORT).show(); } return true; } @Override public boolean onStopJob(JobParameters params) { Log.i(&quot;castiel&quot;, &quot;执行了onStopJob方法&quot;); scheduleJob(getJobInfo()); return true; } //将任务作业发送到作业调度中去 public void scheduleJob(JobInfo t) { Log.i(&quot;castiel&quot;, &quot;调度job&quot;); JobScheduler tm = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); tm.schedule(t); } public JobInfo getJobInfo(){ JobInfo.Builder builder = new JobInfo.Builder(kJobId++, new ComponentName(this, JobCastielService.class)); builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY); builder.setPersisted(true); builder.setRequiresCharging(false); builder.setRequiresDeviceIdle(false); //间隔100毫秒 builder.setPeriodic(100); return builder.build(); } // 判断服务是否正在运行 public boolean isServiceWork(Context mContext, String serviceName) { boolean isWork = false; ActivityManager myAM = (ActivityManager) mContext .getSystemService(Context.ACTIVITY_SERVICE); List&lt;RunningServiceInfo&gt; myList = myAM.getRunningServices(100); if (myList.size() &lt;= 0) { return false; } for (int i = 0; i &lt; myList.size(); i++) { String mName = myList.get(i).service.getClassName().toString(); if (mName.equals(serviceName)) { isWork = true; break; } } return isWork; } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Service保活（二）之双进程守护]]></title>
      <url>%2F2017%2F06%2F04%2FAndroid%20Service%E4%BF%9D%E6%B4%BB%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%8F%8C%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4%2F</url>
      <content type="text"><![CDATA[在上一章中，我们谈到了Android Service防杀的常用套路，随着越来越多的用户手机安装某卫士，某管家，常用的进程防杀套路并不能够很好的保证我们的APP进程常驻，因此本篇我给大家带来抗某卫士，某管家的双进程守护解决方案。 双进程守护，其实原理非常简单，网上也有很多博文讲述，今天我给大家用一个完整的案例来讲述。假设我们的APP中开启了两个Service，分别是A和B，那么：如果A守护B，则B挂掉的同时，A就应该把B启动起来，反之亦然，也就是说A和B应该是互相守护，无论谁被杀掉，对方就把它拉起来。 既然提到了两个Service，那么这两个Service就不能让它们同处在一个进程中，否则就会被一次性双杀。这里我们很容易想到IPC技术，在Android中通常我们可以使用AIDL来实现IPC操作。废话不多说，直接上代码。先来看下项目整体结构： 这里，我们定义两个Service，分别是LocalCastielService和RemoteCastielService，其中的RemoteCastielService我们通过属性配置android:process=”:com.castiel.remote” ，让它成为远端进程。 ####LocalCastielService.Java public class LocalCastielService extends Service { MyBinder myBinder; private PendingIntent pintent; MyServiceConnection myServiceConnection; @Override public void onCreate() { super.onCreate(); if (myBinder == null) { myBinder = new MyBinder(); } myServiceConnection = new MyServiceConnection(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { this.bindService(new Intent(this, RemoteCastielService.class), myServiceConnection, Context.BIND_IMPORTANT); Notification notification = new Notification(R.drawable.ic_launcher, &quot;猴子服务启动中&quot;, System.currentTimeMillis()); pintent = PendingIntent.getService(this, 0, intent, 0); notification.setLatestEventInfo(this, &quot;猴子服务&quot;, &quot;防止被杀掉！&quot;, pintent); // 设置service为前台进程，避免手机休眠时系统自动杀掉该服务 startForeground(startId, notification); return START_STICKY; } class MyServiceConnection implements ServiceConnection { @Override public void onServiceConnected(ComponentName arg0, IBinder arg1) { Log.i(&quot;castiel&quot;, &quot;远程服务连接成功&quot;); } @Override public void onServiceDisconnected(ComponentName arg0) { // 连接出现了异常断开了，RemoteService被杀掉了 Toast.makeText(LocalCastielService.this, &quot;远程服务Remote被干掉&quot;, Toast.LENGTH_LONG).show(); // 启动RemoteCastielService LocalCastielService.this.startService(new Intent(LocalCastielService.this, RemoteCastielService.class)); LocalCastielService.this.bindService(new Intent(LocalCastielService.this, RemoteCastielService.class), myServiceConnection, Context.BIND_IMPORTANT); } } class MyBinder extends CastielProgressConnection.Stub { @Override public String getProName() throws RemoteException { return &quot;Local猴子搬来的救兵 http://blog.csdn.net/mynameishuangshuai&quot;; } } @Override public IBinder onBind(Intent arg0) { return myBinder; } } ####RemoteCastielService.java public class RemoteCastielService extends Service { MyBinder myBinder; private PendingIntent pintent; MyServiceConnection myServiceConnection; @Override public void onCreate() { super.onCreate(); if (myBinder == null) { myBinder = new MyBinder(); } myServiceConnection = new MyServiceConnection(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { this.bindService(new Intent(this,LocalCastielService.class), myServiceConnection, Context.BIND_IMPORTANT); Notification notification = new Notification(R.drawable.ic_launcher, &quot;猴子服务启动中&quot;, System.currentTimeMillis()); pintent=PendingIntent.getService(this, 0, intent, 0); notification.setLatestEventInfo(this, &quot;猴子服务&quot;, &quot;防止被杀掉！&quot;, pintent); //设置service为前台进程，避免手机休眠时系统自动杀掉该服务 startForeground(startId, notification); return START_STICKY; } class MyServiceConnection implements ServiceConnection { @Override public void onServiceConnected(ComponentName arg0, IBinder arg1) { Log.i(&quot;castiel&quot;, &quot;本地服务连接成功&quot;); } @Override public void onServiceDisconnected(ComponentName arg0) { // 连接出现了异常断开了，LocalCastielService被杀死了 Toast.makeText(RemoteCastielService.this, &quot;本地服务Local被干掉&quot;, Toast.LENGTH_LONG).show(); // 启动LocalCastielService RemoteCastielService.this.startService(new Intent(RemoteCastielService.this,LocalCastielService.class)); RemoteCastielService.this.bindService(new Intent(RemoteCastielService.this,LocalCastielService.class), myServiceConnection, Context.BIND_IMPORTANT); } } class MyBinder extends CastielProgressConnection.Stub { @Override public String getProName() throws RemoteException { return &quot;Remote猴子搬来的救兵 http://blog.csdn.net/mynameishuangshuai&quot;; } } @Override public IBinder onBind(Intent arg0) { return myBinder; } } ####aidl文件 package com.castiel.aidl; interface CastielProgressConnection{ String getProName(); } ####启动服务 public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 启动本地服务和远程服务 startService(new Intent(this, LocalCastielService.class)); startService(new Intent(this, RemoteCastielService.class)); } 通过以上代码可以看出，双进程守护实现代码非常简单，两个服务相互连接，Local服务连接着Remote服务，Remote服务又连接着Local服务，你中有我我中有你，一旦两个服务发现对方被杀掉，另一服务立刻会启动并连接它]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Service保活（一）之常用套路]]></title>
      <url>%2F2017%2F05%2F27%2FAndroid%20Service%E4%BF%9D%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF%2F</url>
      <content type="text"><![CDATA[进程、服务守护防杀的实现，对于每一位开发者来说，都是一部与某系统、某卫士、某助手、某管家、某大师斗争的血泪史。我们常用的进程守护的套路无外乎以下几种 ####套路一.提高进程的优先级数值对于Service被系统回收，一般做法是通过提高优先级可以解决，在AndroidManifest.xml文件中对于intent-filter可以通过Android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低。 ####套路二.改变进程等级Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是: 前台进程( FOREGROUND_APP) 可视进程(VISIBLE_APP ) 次要服务进程(SECONDARY_SERVER ) 后台进程 (HIDDEN_APP) 内容供应节点(CONTENT_PROVIDER) 空进程(EMPTY_APP) 我们可以用 setForeground(true) 来设置 Service 的优先级。 如果service正在调用onCreate,onStartCommand或者onDestory方法，那么用于当前service的进程则变为前台进程以避免被killed。 如果当前service已经被启动(start)，拥有它的进程则比那些用户可见的进程优先级低一些，但是比那些不可见的进程更重要，这就意味着service一般不会被killed. 如果客户端已经连接到service(bindService),那么拥有Service的进程则拥有最高的优先级，可以认为service是可见的。 如果service可以使用startForeground(int,Notification)方法来将service设置为前台状态，那么系统就认为是对用户可见的，并不会在内存不足时killed。 如果有其他的应用组件作为Service,Activity等运行在相同的进程中，那么将会增加该进程的重要性。####套路三.设置 android:persistent属性为true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android插件化（二）之调用外部dex文件中的代码]]></title>
      <url>%2F2017%2F05%2F21%2FAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8dex%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[Java程序中，JVM虚拟机是通过类加载器ClassLoader加载.jar文件里面的类的。Android也类似，不过Android用的是Dalvik/ART虚拟机，不是JVM，也不能直接加载.jar文件，而是加载dex文件。 先要通过Android SDK提供的DX工具把.jar文件优化成.dex文件，然后Android的虚拟机才能加载。注意，有的Android应用能直接加载.jar文件，那是因为这个.jar文件已经经过优化，只不过后缀名没改（其实已经是.dex文件）。 ##一、jar文件优化成.dex文件 首先我们可以通过JDK的编译命令javac把Java代码编译成.class文件，再使用jar命令把.class文件封装成.jar文件，这与编译普通Java程序的时候完全一样。之后再用Android SDK的DX工具把.jar文件优化成.dex文件（在“android-sdk\build-tools\具体版本\”路径下） dx --dex --output=target.dex origin.jar // target.dex就是我们要的了 此外，我们可以现把代码编译成APK文件，再把APK里面的.dex文件解压出来，或者直接把APK文件当成.dex使用（只是APK里面的静态资源文件我们暂时还用不到）。至此我们发现，无论加载.jar，还是.apk，其实都和加载.dex是等价的，Android能加载.jar和.apk，是因为它们都包含有.dex，直接加载.apk文件时，ClassLoader也会自动把.apk里的.dex解压出来。 ##二、加载并调用.dex里面的方法 与JVM不同，Android的虚拟机不能用ClassCload直接加载.dex，而是要用DexClassLoader或者PathClassLoader,他们都是ClassLoader的子类，这两者的区别是1) DexClassLoader：可以加载jar/apk/dex，可以从SD卡中加载未安装的apk；2) PathClassLoader：要传入系统中apk的存放Path，所以只能加载已经安装的apk文件；使用前，先看看DexClassLoader的构造方法 public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) { super((String) null, (File) null, (String) null, (ClassLoader) null); throw new RuntimeException(&quot;Stub!&quot;); } 注意，我们之前提到的，DexClassLoader并不能直接加载外部存储的.dex文件，而是要先拷贝到内部存储里。这里的dexPath就是.dex的外部存储路径，而optimizedDirectory则是内部路径，libraryPath用null即可，parent则是要传入当前应用的ClassLoader，这与ClassLoader的“双亲代理模式”有关。 File optimizedDexOutputPath = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + &quot;test_dexloader.jar&quot;);// 外部路径 File dexOutputDir = this.getDir(&quot;dex&quot;, 0);// 无法直接从外部路径加载.dex文件，需要指定APP内部路径作为缓存目录（.dex文件会被解压到此目录） DexClassLoader dexClassLoader = new DexClassLoader(optimizedDexOutputPath.getAbsolutePath(), dexOutputDir.getAbsolutePath(), null, getClassLoader()); 到这里，我们已经成功把.dex文件给加载进来了，接下来就是如何调用.dex里面的代码，主要有两种方式。 ##三、如何调用.dex里面的代码 使用反射的方式 使用DexClassLoader加载进来的类，我们本地并没有这些类的源码，所以无法直接调用，不过可以通过反射的方法调用，简单粗暴。 DexClassLoader dexClassLoader = new DexClassLoader(optimizedDexOutputPath.getAbsolutePath(), dexOutputDir.getAbsolutePath(), null, getClassLoader()); Class libProviderClazz = null; try{ libProviderClazz=dexClassLoader.loadClass(&quot;com.dexclassloader.MyLoader&quot;); // 遍历类里所有方法 Method[]methods=libProviderClazz.getDeclaredMethods(); for(int i=0;i&lt;methods.length;i++){ Log.e(TAG,methods[i].toString()); } Method start=libProviderClazz.getDeclaredMethod(&quot;func&quot;);// 获取方法 start.setAccessible(true);// 把方法设为public，让外部可以调用 String string=(String)start.invoke(libProviderClazz.newInstance());// 调用方法并获取返回值 Toast.makeText(this,string,Toast.LENGTH_LONG).show(); }catch(Exception exception){ // Handle exception gracefully here. exception.printStackTrace(); } 使用接口的方式毕竟.dex文件也是我们自己维护的，所以可以把方法抽象成公共接口，把这些接口也复制到主项目里面去，就可以通过这些接口调用动态加载得到的实例的方法了。 pulic interface IFunc{ public String func(); } // 调用 IFunc ifunc = (IFunc)libProviderClazz; String string = ifunc.func(); Toast.makeText(this, string, Toast.LENGTH_LONG).show(); 到这里，我们已经成功从外部路径动态加载一个.dex文件，并执行里面的代码逻辑了。通过从服务器下载最新的.dex文件并替换本地的旧文件，就能初步实现“APP的动态升级了”。 虽然我们已经能调用插件的方法了，但是还有如下问题 无法使用res目录下的资源，特别是使用XML布局，以及无法通过res资源到达自适应无法动态加载新的Activity等组件，因为这些组件需要在Manifest中注册，动态加载无法更改当前APK的Manifest这些问题的解决方案，将在以后的博客进行说明。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android插件化（一）之谈谈ClassLoader]]></title>
      <url>%2F2017%2F05%2F14%2FAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E8%B0%88%E8%B0%88ClassLoader%2F</url>
      <content type="text"><![CDATA[##一、什么是ClassLoader?Java程序是由若干.class文件组成，程序运行在虚拟机上时，会调用该程序的入口函数来调用系统的相关功能，而这些功能都被封装在不同的.class文件中。虚拟机根据程序的需要，通过Java的类加载机制来动态加载某个class文件到内存当中，只有class文件被载入到了内存之后，才能被其它class所引用，而完成这一个加载工作的角色就是ClassLoader。 ##二、Android中的ClassLoader @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); ClassLoader classLoader = getClassLoader(); if (classLoader != null) { Log.i(TAG, &quot;onCreate classLoader &quot; + i + &quot; : &quot; + classLoader.toString()); while (classLoader.getParent() != null) { classLoader = classLoader.getParent(); i = i + 1; Log.i(TAG, &quot;onCreate classLoader &quot; + i + &quot; : &quot; + classLoader.toString()); } } } 可以看见有2个Classloader实例，一个是BootClassLoader，另一个是PathClassLoader,由此也可以看出，一个运行的Android应用至少有2个ClassLoader。查看官方文档我们可以知道Android中类加载器有BootClassLoader,URLClassLoader,PathClassLoader,DexClassLoader,BaseDexClassLoader 等都最终继承自java.lang.ClassLoader。 ##三、使用ClassLoader加载类在前面我们看到，Android程序启动过程中，会有一个dalvik.system.PathClassLoader,查看官方文档PathClassLoader,可以得知，PathClassLoader是ClassLoader的一个简单实现，主要用于加载系统类和加载应用中的类。 查看父类BaseDexClassLoader可以看到ClassLoader还有一个实现：DexClassLoader,通过官方文档可以得知，DexClassLoader加载.jar或者apk里面的class.dex文件，可以用于加载未安装的代码。而我们研究动态加载的目的主要是用于插件化或者热更新功能，加载的代码必然也是未安装的，所以我们要用的就是DexClassLoader。 实例化DexClassLoader首先我们看下DexClassLoader的构造函数 public class DexClassLoader extends BaseDexClassLoader { public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) {super(dexPath, new File(optimizedDirectory), libraryPath, parent); } }参数详解：dexPath：dex文件路径列表，多个路径使用”:”分隔optimizedDirectory：经过优化的dex文件输出目录，必须是应用私有目录libraryPath：动态库路径（将被添加到app动态库搜索路径列表中）parent：现有的ClassLoader实例，这个参数的主要作用是保留java中ClassLoader的双亲代理模型（优先父类加载器加载classes，由上而下的加载机制，防止重复加载类字节码） loadClassJVM中ClassLoader通过defineClass方法加载jar里面的Class，而Android中这个方法被弃用了。 @Deprecated protected final Class&lt;?&gt; defineClass(byte[] classRep, int offset, int length) throws ClassFormatError { throw new UnsupportedOperationException(“can’t load this type of class file”); }DexClassLoader中使用loadClass方法 public Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException { return loadClass(className, false); } protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException { Class&lt;?&gt; clazz = findLoadedClass(className); if (clazz == null) { ClassNotFoundException suppressed = null; try { clazz = parent.loadClass(className, false); } catch (ClassNotFoundException e) { suppressed = e; } if (clazz == null) { try { clazz = findClass(className); } catch (ClassNotFoundException e) { e.addSuppressed(suppressed); throw e; } } } return clazz;从源码中我们也可以看出，loadClass方法在加载一个类的实例的时候1) 会先查询当前ClassLoader实例是否加载过此类，有就返回； 2) 如果没有。查询Parent是否已经加载过此类，如果已经加载过，就直接返回Parent加载的类； 3) 如果继承路线上的ClassLoader都没有加载，才由Child执行类的加载工作； 这样做有个明显的特点，如果一个类被位于树根的ClassLoader加载过，那么在以后整个系统的生命周期内，这个类永远不会被重新加载。也就是双亲代理模型体现。 ##四、结束语通过上面的分析，我们知道使用ClassLoader动态加载一个外部的类是非常容易的事情，所以很容易就能实现动态加载新的可执行代码的功能，但是比起一般的Java程序，在Android程序中使用动态加载主要有两个麻烦的问题： 1) Android中许多组件类（如Activity、Service等）是需要在Manifest文件里面注册后才能工作的（系统会检查该组件有没有注册），所以即使动态加载了一个新的组件类进来，没有注册的话还是无法工作； 2) Res资源是Android开发中经常用到的，而Android是把这些资源用对应的R.id注册好，运行时通过这些ID从Resource实例中获取对应的资源。如果是运行时动态加载进来的新类，那类里面用到R.id的地方将会抛出找不到资源或者用错资源的异常，因为新类的资源ID根本和现有的Resource实例中保存的资源ID对不上。这两个问题，将在后续章节讲解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android系统版本差异及注意事项]]></title>
      <url>%2F2017%2F05%2F06%2FAndroid%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[一、Android 7.0 Nougat 分屏，实现多任务管理。用户可以一次在屏幕上打开两个应用。 在手机上，两个应用可以在“分屏”模式中左右并排或上下并排显示。 在电视设备上，应用可以使用“画中画”模式，在用户与另一个应用交互的同时继续播放视频。 通知栏快捷回复。实时通信应用，Android 系统支持内联回复，以便用户可以直接在通知界面中快速回复短信 引入全新的JIT编译器，使得App安装速度快了75%，编译代码的规模减少了50% 移除三项广播：CONNECTIVITY_ACTION（监听网络变化）、ACTION_NEW_PICTURE 和ACTION_NEW_VIDEO（监听相机） 新增省流量模式 支持VR ###支持分屏如果您的应用面向 Android N，您可以对应用的 Activity 是否支持多窗口显示以及显示方式进行配置。官方文档有详细的处理流程。 多窗口模式不会更改 Activity 生命周期在多窗口模式中，在指定时间只有最近与用户交互过的 Activity 为活动状态。 该 Activity 将被视为顶级 Activity。 所有其他 Activity 虽然可见，但均处于暂停状态。 但是，这些已暂停但可见的 Activity 在系统中享有比不可见 Activity 更高的优先级。 如果用户与其中一个暂停的 Activity 交互，该 Activity 将恢复，而之前的顶级 Activity 将暂停。 启用或禁用多窗口显示在AndroidMainfest.xml文件的 或 节点中设置该属性 android:resizeableActivity=[“true” | “false”] 如果该属性设置为 true，Activity 将能以分屏和自由形状模式启动。 如果此属性设置为 false，Activity 将不支持多窗口模式。 如果该值为 false，且用户尝试在多窗口模式下启动 Activity，该 Activity 将全屏显示。 如果您的应用的targetVersion为24，但未对该属性指定值，则该属性的值默认设为 true。 支持画中画显示在清单文件的 节点中设置该属性，指明 Activity 是否支持画中画显示。 如果 android:resizeableActivity 为 false，将忽略该属性。 android:supportsPictureInPicture=[“true” | “false”] 分屏和自由形状模式中 Activity 的最小高度和最小宽度android:minimalHeight、android:minimalWidth例如，以下节点显示了如何指定 Activity 在自由形状模式中显示时 Activity 的默认大小、位置和最小尺寸： ##二、Android 6.0 Marshmallow 运行时权限当应用的targetVersion设置为23时，在运行时需要检查和请求危险权限。checkSelfPermission() 方法用于验证用户是否授予权限；requestPermissions() 方法用于向用户请求权限。 低电耗模式和应用待机模式低电耗模式：如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。应用待机模式：应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业。 移除对Apache HTTP client的支持建议使用HttpURLConnection。如果还是想用Apache HTTP client，那么需要在build.gradle中添加 android { useLibrary &apos;org.apache.http.legacy&apos; } 移除了 Notification.setLatestEventInfo() 方法。构建通知用 Notification.Builder 类 文本选择当用户在应用中选择文本时，可以在一个浮动工具栏中显示“剪切”、“复制”和“粘贴”等文本选择操作。 ##三、Android 5.0 Lollipop Material designMaterial design算是Android 系统风格的里程碑，其3D UI风格新颖，贴近人机交互； 改善通知栏，提升可视化、亲近性、可编辑性。同时支持手机在锁屏状态也可接收到通知，用户可以在锁屏状态下，设置接收全部应用的通知或者接收部分应用的通知或者不接收所有应用的通知； ART（Android Runtime）运行时取代 Dalvik 成为平台默认设置，实现ahead-of-time (AOT)静态编译与just-in-time (JIT)动态编译交互进行； V7中引入CardView和RecycleView等新控件； 开放屏幕采集API通过MediaProjection屏幕采集API，可以实现录屏功能。 新增 JobScheduler APIJobScheduler API允许推迟或指定条件下（如设备充电或连入 WLAN 时）创建执行在后台的任务。 Context.bindService() 方法现在需要显式 Intent，如果提供隐式 intent，将引发异常。为确保应用的安全性，请使用显式 intent 启动或绑定 Service，且不要为服务声明 intent 过滤器。 新安装和更新需要验证自定义权限如果应用定义了一个已安装应用定义的自定义权限，且应用没有使用与该已安装应用相同的签名密钥，则系统不会重新安装应用。 支持64位系统； 处理 Intent在触发任何 intent 之前检查是否至少有一个适合此 intent 的处理程序。要检查是否存在有效的处理程序，可以调用 Intent.resolveActivity()，避免导致 ActivityNotFoundException。 电池使用情况统计新增的 dumpsys batterystats 命令可生成电池使用情况统计信息，通过它了解整个系统的耗电情况，以及了解应用对设备电池的影响。可以查看耗电事件历史记录、每个 UID 和系统组件的近似耗电情况以及其他信息。 新增了“电池耗电历史”工具，可将来自 dumpsys batterystats 的统计数据转换成可视化格式，以便进行与电池有关的调试。 启用TLSv1.2 和 TLSv1.1 协议某些服务器使用了TLSv1.2，使用WebView打开时，5.0以下的设备页面无法正常打开。 ###使用Material design 设置应用的 targetSdkVersion 和 targetSdkVersion 为21 在values目录下的style资源文件中创建一个style，让其继承自 android:Theme.Material 在AndroidManifest中指定应用的主题或者Activity的主题为我们设定的样式 谷歌官方我们提供了三种配色风格的Material Design样式：黑色主题 Theme.Material明亮主题 Theme.Material.Light明亮主题黑色ActionBar Theme.Material.Light.DarkActionBar ##四、Android 4.4 KitKat 通过主机卡模拟实现新的 NFC 功能 打印框架Android 应用可以通过 WLAN 或云托管服务（例如 Google 云打印）打印任何类型的内容。在支持打印的应用中，用户可以发现可用的打印机，更改纸张尺寸，选择要打印的特定页面，打印几乎任何种类的文档、图像或文件。 步测器和计步器可以在用户行走、跑步或攀爬楼梯时跟踪步数。 全屏沉浸模式系统 UI 保持隐藏状态，在沉浸模式中，从屏幕顶部或底部边缘滑动手指可以显示系统 UI。 Chromium WebView支持使用 Chrome DevTools 进行远程调试。例如，可以在开发机器上使用 Chrome DevTools 检测、调试和分析移动设备中存储的 WebView 内容。 屏幕录制使用命令 adb shell screenrecord 或者通过 Android Studio 中的 DDMS 分析设备内存状态Settings &gt; Developer options &gt; Process stats##五、Android 4.X Jelly Bean UiAutomation自动化UI测试]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化（四）之启动速度优化]]></title>
      <url>%2F2017%2F04%2F29%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[##一、前言 随着项目版本的迭代，App的性能问题会逐渐暴露出来，而好的用户体验与性能表现紧密相关，从本篇文章开始，我将开启一个Android应用性能优化的专题，从理论到实战，从入门到深挖，手把手将性能优化实践到项目中，欢迎持续关注！ 那么第一篇文章我就从应用的启动优化开始，根据实际案例，打造闪电般的App启动速度。 ##二、初识启动加速 来看一下Google官方文档《Launch-Time Performance》对应用启动优化的概述； 应用的启动分为冷启动、热启动、温启动，而启动最慢、挑战最大的就是冷启动：系统和App本身都有更多的工作要从头开始！应用在冷启动之前，要执行三个任务： 加载启动App； App启动之后立即展示出一个空白的Window； 创建App的进程； 而这三个任务执行完毕之后会马上执行以下任务： 创建App对象； 启动Main Thread； 创建启动的Activity对象； 加载View； 布置屏幕； 进行第一次绘制； 而一旦App进程完成了第一次绘制，系统进程就会用Main Activity替换已经展示的Background Window，此时用户就可以使用App了。 作为普通应用，App进程的创建等环节我们是无法主动控制的，可以优化的也就是Application、Activity创建以及回调等过程。同样，Google也给出了启动加速的方向： 利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验； 避免在启动时做密集沉重的初始化（Heavy app initialization）； 定位问题：避免I/O操作、反序列化、网络操作、布局嵌套等。 备注：方向1属于治标不治本，只是表面上快；方向2、3可以真实的加快启动速度。接下来我们就在项目中实际应用。 ##三、启动加速之闪屏图 按照官方文档的说明：使用Activity的windowBackground主题属性来为启动的Activity提供一个简单的drawable。Layout XML file: &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:opacity=&quot;opaque&quot;&gt; &lt;!-- The background color, preferably the same as your normal theme --&gt; &lt;item android:drawable=&quot;@android:color/white&quot;/&gt; &lt;!-- Your product logo - 144dp color version of your app icon --&gt; &lt;item&gt; &lt;bitmap android:src=&quot;@drawable/product_logo_144dp&quot; android:gravity=&quot;center&quot;/&gt; &lt;/item&gt; &lt;/layer-list&gt; Manifest file: &lt;activity ... android:theme=&quot;@style/AppTheme.Launcher&quot; /&gt; onCreate： public class MyMainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { // Make sure this is before calling super.onCreate setTheme(R.style.Theme_MyApp); super.onCreate(savedInstanceState); // ... } } 这样在启动的时候，会先展示一个界面，这个界面就是Manifest中设置的Style，等Activity加载完毕后，再去加载Activity的界面，而在Activity的界面中，我们将主题重新设置为正常的主题，从而产生一种快的感觉。不过如上文总结这种方式其实并没有真正的加速启动过程，而是通过交互体验来优化了展示的效果。 ##四、启动加速之Avoid Heavy App Initialization 通过代码分析我们可以得到App启动的业务工作流程图：考虑异步初始化三方组件，不阻塞主线程；延迟部分三方组件的初始化；实际上我们粗粒度的把所有三方组件都放到异步任务里，可能会出现WorkThread中尚未初始化完毕但MainThread中已经使用的错误，因此这种情况建议延迟到使用前再去初始化；而如何开启WorkThread同样也有讲究，这个话题在下文详谈。项目修改： 将友盟、Bugly、听云、GrowingIO、BlockCanary等组件放在WorkThread中初始化；延迟地图定位、ImageLoader、自有统计等组件的初始化：地图及自有统计延迟4秒，此时应用已经打开；而ImageLoader因为调用关系不能异步以及过久延迟，初始化从Application延迟到SplashActivity；而EventBus因为再Activity中使用所以必须在Application中初始化。 ##五、启动加速之Diagnosing The Problem 本节我们实际定位耗时的操作，在开发阶段我们一般使用BlockCanary或者ANRWatchDog找耗时操作，简单明了，但是无法得到每一个方法的执行时间以及更详细的对比信息。我们可以通过Method Tracing或者DDMS来获得更全面详细的信息。启动应用，点击 Start Method Tracing，应用启动后再次点击，会自动打开刚才操作所记录下的.trace文件，建议使用DDMS来查看，功能更加方便全面。卡顿不能都靠异步来解决，错误的使用工程线程不仅不能改善卡顿，反而可能加剧卡顿。是否需要开启工作线程需要根据具体的性能瓶颈根源具体分析，对症下药，不可一概而论；而如何开启线程同样也有学问：Thread、ThreadPoolExecutor、AsyncTask、HandlerThread、IntentService等都各有利弊；例如通常情况下ThreadPoolExecutor比Thread更加高效、优势明显，但是特定场景下单个时间点的表现Thread会比ThreadPoolExecutor好：同样的创建对象，ThreadPoolExecutor的开销明显比Thread大；正确的开启线程也不能包治百病，例如执行网络请求会创建线程池，而在Application中正确的创建线程池势必也会降低启动速度；因此延迟操作也必不可少。通过对traceview的详细跟踪以及代码的详细比对，我发现卡顿发生在： 部分数据库及IO的操作发生在首屏Activity主线程；Application中创建了线程池；首屏Activity网络请求密集；工作线程使用未设置优先级；信息未缓存，重复获取同样信息；流程问题：例如闪屏图每次下载，当次使用；以及其它细节问题： 执行无用老代码；执行开发阶段使用的代码；执行重复逻辑；调用三方SDK里或者Demo里的多余代码；项目修改： 数据库及IO操作都移到工作线程，并且设置线程优先级为THREAD_PRIORITY_BACKGROUND，这样工作线程最多能获取到10%的时间片，优先保证主线程执行。 流程梳理，延后执行；实际上，这一步对项目启动加速最有效果。通过流程梳理发现部分流程调用时机偏早、失误等，例如： 更新等操作无需在首屏尚未展示就调用，造成资源竞争；调用了IOS为了规避审核而做的开关，造成网络请求密集；自有统计在Application的调用里创建数量固定为5的线程池，造成资源竞争，在上图traceview功能说明图中最后一行可以看到编号12执行5次，耗时排名前列；此处线程池的创建是必要但可以延后的。修改广告闪屏逻辑为下次生效。3.其它优化； 去掉无用但被执行的老代码；去掉开发阶段使用但线上被执行的代码；去掉重复逻辑执行代码；去掉调用三方SDK里或者Demo里的多余代码；信息缓存，常用信息只在第一次获取，之后从缓存中取；项目是多进程架构，只在主进程执行Application的onCreate()；通过以上三步及三方组件的优化：Application以及首屏Activity回调期间主线程就没有耗时、争抢资源等情况了。此外还涉及布局优化、内存优化等部分技术，因对于应用冷启动一般不是瓶颈点，这里不展开详谈，可根据实际项目实际处理。 ##六、常用工具： ###1.display time从Android KitKat版本开始，Logcat中会输出从程序启动到某个Activity显示到画面上所花费的时间。这个方法比较适合测量程序的启动时间。 ###2.调用Activity的reportFullyDrawn()方法我们通常来说会使用异步懒加载的方式来提升程序画面的显示速度，这通常会导致的一个问题是，程序画面已经显示，可是内容却还在加载中。为了衡量这些异步加载资源所耗费的时间，我们可以在异步加载完毕之后调用activity.reportFullyDrawn()方法来告诉系统此时的状态，以便获取整个加载的耗时。在4.4上调用reportFullyDrawn()方法会崩溃（但是log还是能正常打印），提示需要UPDATE_DEVICE_STATS权限 ，但是这个权限只有系统app才能授权。解决的办法是这样调用： try{ reportFullyDrawn(); }catch(SecurityException e){ } ###3.Method Tracing前面两个方法提供了启动耗时的总时间，可是却无法提供具体的耗时细节。为了获取具体的耗时分布情况，我们可以使用Method Tracing工具来进行详细的测量。 ###4.Systrace我们可以在onCreate方法里面添加trace.beginSection()与trace.endSection()方法来声明需要跟踪的起止位置，系统会帮忙统计中间经历过的函数调用耗时，并输出报表。 ###5.adb命令通过ADB命令统计应用的启动时间：adb shell am start -W 首屏Activity。同等条件下使用MX3及Nexus6P，启动5次，比较优化前与优化后的启动时间； 命令含义：ThisTime:最后一个启动的Activity的启动耗时；TotalTime:自己的所有Activity的启动耗时；WaitTime: ActivityManagerService启动App的Activity时的总时间（包括当前Activity的onPause()和自己Activity的启动）。 ##七、优化方向1）优化布局耗时：一个布局层级越深，里面包含需要加载的元素越多，就会耗费更多的初始化时间。关于布局性能的优化，这里就不展开描述了！ 2）异步延迟加载：一开始只初始化最需要的布局，异步加载图片，非立即需要的组件可以做延迟加载。 3) 在application里面做延迟加载，也可以把一些初始化的操作延迟到组件真正被调用到的时候再做加载。 ##八、问题： 1、还可以继续优化的方向？ 项目里使用Retrofit网络请求库，FastConverterFactory做Json解析器，TraceView中看到FastConverterFactory在创建过程中也比较耗时，考虑将其换为GsonConverterFactory。但是因为类的继承关系短时间内无法直接替换，作为优化点暂时遗留；可以考虑根据实际情况将启动时部分接口合并为一，减少网络请求次数，降低频率；相同功能的组件只保留一个，例如：友盟、GrowingIO、自有统计等功能重复；使用ReDex进行优化；实验Redex发现Apk体积确实是小了一点，但是启动速度没有变化，或许需要继续研究。2、异步、延迟初始化及操作的依据？注意一点：并不是每一个组件的初始化以及操作都可以异步或延迟；是否可以取决组件的调用关系以及自己项目具体业务的需要。保证一个准则：可以异步的都异步，不可以异步的尽量延迟。让应用先启动，再操作。 3、通用应用启动加速套路？ 利用主题快速显示界面；异步初始化组件；梳理业务逻辑，延迟初始化组件、操作；正确使用线程；去掉无用代码、重复逻辑等。4、其它 将启动速度加快了35%不代表之前的代码都是问题，从业务角度上将，代码并没有错误，实现了业务需求。但是在启动时这个注重速度的阶段，忽略的细节就会导致性能的瓶颈。开发过程中，对核心模块与应用阶段如启动时，使用TraceView进行分析，尽早发现瓶颈。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化（三）之读书笔记]]></title>
      <url>%2F2017%2F04%2F23%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Android性能优化主要几个方面: 布局优化 绘制优化 内存泄漏优化 响应速度优化 ListView, Bitmap, 线程优化 ##布局优化布局优化的思想就是尽量较少布局文件的层级,这就可以让Android绘制时的工作量减少 删除无用的控件和层级, 有选择地使用ViewGroup. 例如RelativeLayout和LinearLayout. 都可以的话那么就采用LinearLayout. 因为RelativeLayout的功能比较复杂, 它的布局过程需要花费更多的CPU时间. FrameLayout和LinearLayout都是一种简单高效的ViewGroup. 如果需要嵌套才可以实现的布局那么就是用RelativeLayout. 布局优化的另外一个方法就是采用标签, 标签和ViewStub. include主要用于布局的重用 merge一般和include标签配合使用, 它可以减少布局的层级 ViewStub: 提供了按需加载的功能, 当需要时才会将ViewStub中的布局加载到内存,这可以提高程序的初始化. include标签 可以将一个指定的布局文件加载到当前布局文件中: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;include android:id=&quot;@+id/hah&quot; android:layout=&quot;@layout/layout_titlebar&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; android:visibility=&quot;invisible&quot;/&gt; &lt;/LinearLayout&gt; 这个标签里面支持的属性很少, 根据编辑器的提示只有5个, 而且width和height如果要出现需要同时出现, 也可以不写, 最重要的就是一个必须指定导入的布局layout=”xxxxxx”. merge 这个标签一般和include标签一起使用从而减少布局的层级. 有时候会有这样一个场景, 如果include导入的布局的根布局是竖直方向的, 而当前布局也是竖直方向的, 那么和显然有一个层级是多余的. 这个时候使用就可以去掉重复布局. ViewStub ViewStub继承了View, 这是一个非常轻量级的且宽高都是0, 因此它本身不参与任何的布局和绘制过程. 而ViewStub存在的意义在于按需加载所需的布局文件, 在实际开发中, 有很多布局文件在正常情况系不会显示, 如网络异常等. 这个时候就没有必要再整个界面初始化的时候将其加载. 首先布局中添加 &lt;ViewStub android:id=&quot;@+id/stub_import&quot; android:inflatedId=&quot;@+id/stin_root&quot; android:layout=&quot;@layout/layout_stubview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot;/&gt; 这里android:layout属性还是导入外部布局的意思. inflatedId这个添加的id的属性是给导入进来的布局layout_stubview的根布局设定了一个id值. 然后在代码中有两种方式让其显示 // 方式一 通过设置visibility ((ViewStub)findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); // 方式二 通过inflate加载显示 //View inflate = ((ViewStub) findViewById(R.id.stub_import)).inflate(); // 通过inflatedId这个id可以得到加载进来的布局的根布局 LinearLayout commLv = (LinearLayout) findViewById(R.id.stin_root); ##绘制优化 绘制优化是指View#onDraw()方法要避免执行大量的操作.两个方面 onDraw中不要创建新的局部对象, 因为onDraw()方法可能会被频繁调用, 这样就会在一瞬间产生大量的临时对象, 这不仅占用了过多的内存而且还会导致系统频繁的gc, 降低了程序的执行效率. 不要做耗时任务, 也不能执行成千上万次的循环操作. 即使每次循环都很轻量级, 但是大量的循环仍然十分抢占CPU的时间片, 这会造成View的绘制流程不流畅. 按照官方的规范, View的绘制帧率保证60fps最佳. 也就是16ms的为每一阵帧的绘制时间. ##内存泄漏优化 ###情况1. 静态变量导致的内存泄漏 private static View sView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sView = new View(this); } 如非必须传递Activity的引用不要这么做, 如果需要上下文可以传递getApplicationContext()返回的上下文 ###情况2. 单例模式导致的内存泄漏 常见的就是在使用注册监听的时候, 往往会往一个单例类中传入this本类对象,进行注册, 然后却没有解注册的动作. 那么这个Activity被引用的时间也就是和Application的生命周期持平. ###情况3. 属性动画导致的内存泄漏 在Android 3.0中加入了属性动画, 属性动画有一类无限循环的动画, 如果在Activity中播放此类动画且没有在Activity退出的时候没有停止动画. 尽管无法界面上看到效果, 但是创建这个动画所关联的View被动画所持有, 而View又持有了Activity, 最终Activity无法释放. 解决方案, 就是在onDestroy()中调用动画的cancel()来停止动画. ##响应速度和ANR日志分析响应速度的优化核心就是避免主线程做耗时操作, 响应速度过慢更多体现在Activity启动的速度上. 如果主线程内做太多的事情, 会导致Activity启动时出现黑屏现象, 甚至出现ANR. Android中规定如果Activity5秒钟之内无法响应屏幕事件或者键盘输入事件就会出现ANR. 而BroadCastReceiver如果10秒之内还未执行完操作也会出现ANR. 如果进程发生了ANR以后, 系统会在data/anr目录下创建一个文件traces.txt. 通过分析这个文件就定位出原因.(这个文件很长如果需要分析, 请先删除文件生成一个在分析来进行了解) 通过一个例子来了解如何去分析文件, 首先在onCreate()添加如下代码, 让主线程等待一个锁,然后点击返回5秒后会出现ANR, 贴代码 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 以下代码是为了模拟一个ANR的场景来分析日志 new Thread(new Runnable() { @Override public void run() { testANR(); } }).start(); SystemClock.sleep(10); initView(); } /** * 以下两个方法用来模拟出一个稍微不好发现的ANR */ private synchronized void testANR(){ SystemClock.sleep(3000 * 1000); } private synchronized void initView(){} 这样会出现ANR, 然后导出/data/anr/straces.txt文件. 因为内容比较多只贴出关键部分 DALVIK THREADS (15): &quot;main&quot; prio=5 tid=1 Blocked | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x73db0970 self=0xf4306800 | sysTid=19949 nice=0 cgrp=apps sched=0/0 handle=0xf778d160 | state=S schedstat=( 151056979 25055334 199 ) utm=5 stm=9 core=1 HZ=100 | stack=0xff5b2000-0xff5b4000 stackSize=8MB | held mutexes= at com.szysky.note.androiddevseek_15.MainActivity.initView(MainActivity.java:0) - waiting to lock &lt;0x2fbcb3de&gt; (a com.szysky.note.androiddevseek_15.MainActivity) - held by thread 15 at com.szysky.note.androiddevseek_15.MainActivity.onCreate(MainActivity.java:42) 这段可以看出最后指明了ANR发生的位置在ManiActivity的42行. 并且通过上面看出initView方法正在等待一个锁锁的类型是一个MainActivity对象. 并且这个锁已经被线程id为15(tid=15)的线程持有了. 接下来找一下线程15 &quot;Thread-404&quot; prio=5 tid=15 Sleeping | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12c00f80 self=0xeb95bc00 | sysTid=19985 nice=0 cgrp=apps sched=0/0 handle=0xef34be80 | state=S schedstat=( 391248 0 1 ) utm=0 stm=0 core=2 HZ=100 | stack=0xe2bfe000-0xe2c00000 stackSize=1036KB | held mutexes= at java.lang.Thread.sleep!(Native method) - sleeping on &lt;0x2e3896a7&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1031) - locked &lt;0x2e3896a7&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:985) at android.os.SystemClock.sleep(SystemClock.java:120) at com.szysky.note.androiddevseek_15.MainActivity.testANR(MainActivity.java:50) - locked &lt;0x2fbcb3de&gt; (a com.szysky.note.androiddevseek_15.MainActivity) - tid = 15 就是相关信息如上, 首行已经标出线程的状态为Sleeping, 原因在50行, 就是SystemClock.sleep(3000 * 1000);这句话. 也就是testANR(). 而最后一行也表明了持有的locked&lt;0x2fbcb3de&gt;就是主线程在等待的那个锁对象. ##ListView和Bitmap优化 ListView: 在前面已经说过了, 主要三个方面: 采用ViewHolder避免在getView中执行耗时操作; 其次要根据列表的滑动状态来控制任务的执行频率; 最后可以尝试开启硬件加速是ListView滑动更加流畅. ListView的优化策略也完全适用于GridView Bitmap: 也已经说过, 主要是通过BitmapFactory.Options根据需要对图片进行采样, 采样率的设置通过inSampleSize属性. ##线程优化 主要思想就是采用线程池, 避免程序中存在大量的Thread. 线程池可以重用内部的线程, 避免了线程创建和销毁的性能开销. 同时线程池还能有效的控制线程的最大并发数, 避免了大量线程因互相巷战系统资源从而导致阻塞现象的发生. ##额外的性能优化建议 避免创建过多的对象 不要过多使用枚举, 枚举占用的内存空间比整形还要大,使用Android官方提供的方法可参考另一篇博客链接跳转 常量请使用 static final 来修饰 使用一些Android特有的数据结构, 比如SparseArray和Pair等 适当的使用软引用和弱引用 采用内存缓存和磁盘缓存 尽量采用静态内部类, 避免潜在的由于内部类而导致的内存泄漏 ##内存泄漏分析工具MATMAT全程Eclipse Memory Analyzer, 是一个内存泄漏分析工具. 下载后解压即可. 下载地址http://www.eclipse.org/mat/downloads.php. 这里仅简单说一下. 这个我没有手动去实践, 就当个记录, 因为现在Android Studio可以直接分析hprof文件. 可以手动写一个会造成内存泄漏的代码, 然后打开DDMS, 然后选中要分析的进程, 然后单击Dump HPROF file这个按钮. 等一小段会生成一个文件. 这个文件不能被MAT直接识别. 需要使用Android SDK中的工具进行格式转换一下.这个工具在platform-conv文件夹下 hprof-conv 要转换的文件名 输出的文件名 文件名的签名有包名. 然后打开MAT通过菜单打开转换后的这个文件. 这里常用的就有两个 Histogram: 可以直观的看出内存中不同类型的buffer的数量和占用内存大小 Dominator Tree: 把内存中的对象按照从大到小的顺序进行排序, 并且可以分析对象之间的引用关系, 内 存泄漏分析就是通过这个完成的.分析内存泄漏的时候需要分析Dominator Tree里面的内存信息, 一般会不直接显示出来, 可以按照从大到小的顺序去排查一遍. 如果发生了了泄漏, 那么在泄漏对象处右键单击Path To GC Roots-&gt;exclude wake/soft references. 可以看到最终是什么对象导致的无法释放. 刚才的操作之所以排除软引用和弱引用是因为,大部分情况下这两种类型都可以被gc回收掉,所以基本也就不会造成内存泄漏. 同样这里也可以使用搜索功能, 假如我们手动模拟了内存泄漏, 泄漏的对象就是Activity那么我们back退出重进循环几次, 会发现其实很多个Activit对象. 更多的东西我也不会,作者也没有说.. 不过这些以后Android Studio都会很有好用对应功能. ##提高程序的可维护性这里主要说Android的程序设计思想. 主旨是如何提高代码的可维护性和可扩展性, 而程序的可维护性也包含可扩展性. 这里的切入点为: 代码风格, 代码的层次性和单一职责原则, 面向扩展编程以及设计模式 可读性是代码可维护性的前提, 一段只能让机器读懂的代码即使可以跑也属于”坏味道的代码”, 而良好的代码风格在一定程度上可以提高从程序的可读性. 代码的风格有 命名规范, 代码排版, 注释说明. 命名要规范, 正确传达出变量或者方法的定义, 少用缩写除非业界通用的缩写如String-&gt;str.能让人一眼明白的. 私有成员要以m开头. 静态成员要以s开头. 常量要全部大写. 代码排版上留出合理的空白来区分不同的代码块, 其中同类变量的声明放在一组, 两类变量之间留出一行作为空白. 仅为非常关键的代码添加注释, 其他地方不写注释, 这就对变量和方法的命名风格提出了很高的要求. 一个合理的命名风格可以让读者阅读源码的时候就如阅读注释一样. 因此根本不需要为代码额外写注释 代码的层次是指代码要有分层的概念, 对于一段业务逻辑, 不要试图在一个方法或者一个类中去全部实现, 而是将其分成几个子逻辑, 然后每个逻辑做自己的事情, 这样即显得代码层次分明, 又可以分解任务从而实现简单逻辑的效果. 单一职责是和层次性相关联的. 代码分层以后, 每一层仅仅关注少量的逻辑, 这样就做到了单一职责. 程序的扩展性, 由于很多时候在开发过程中无法保证已经做好的需求不在后面的版本发生更改, 因此在写程序的时候要时刻考虑到扩展的问题, 考虑如果这个逻辑以后发生了改变那么哪些需要修改, 以及怎样在以后修改的时候降低工作量, 而面向扩展编程可以让程序具有很好的扩展性. 适当使用设计模式可以提高代码的可维护性和可扩展性. 但是一定控制设计的度, 千万别过度设计.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化（二）之Monkey性能测试]]></title>
      <url>%2F2017%2F04%2F15%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8BMonkey%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[##一、Monkey简介 Android的SDK 里面，Monkey的tools是一个命令行工具，当连接Android设备时，只要在命令行里输入相应命令就能运行tools； Monkey test是一项压力测试，可以在规定的次数范围内做任何随机的操作，随机操作包括点击、滑动、Application切换、横竖屏、应用关闭等等，用户能做的操作统统可以模拟； Monkey test跑出来crash的bug等级永远为1，版本release前，Monkey跑出的结果中crash要为0。业内标准：final release前，Monkey跑完的总次数应为25W次，其结果里不允许有nullPointException出现. ##二、Monkey命令 标准命令： abd devices 列出所有的已连接的设备（包括真机和虚拟机） adb shell 进入shell模式，查看data/data文件夹中的安装包情况 [adb shell] monkey [options] 栗子：adb shell monkey -v 500 产生500次随机事件，作用与系统中所有的activity（其实也不是所有的activity，而是包含 Intent.CATEGORY_LAUNCHER 或Intent.CATEGORY_MONKEY 的activity）。 ##三、命令分类 常用选项： -help：打印帮助信息-v：指定打印信息的详细级别，一个 -v增加一个级别 ， 默认级别为 0 ,最高为-v -v -v 事件选项； -s：指定产生随机事件种子值，相同的种子值产生相同的事件序列。如： -s 200 --throttle：每个事件结束后的间隔时间——降低系统的压力（如不指定，系统会尽快的发送事件序列）。如：--throttle 100 --pct-touch：指定触摸事件的百分比，如：--pct-touch 5% 相关的还有以下option： --pct-motion &lt;percent&gt; （滑动事件） --pct-trackball &lt;percent&gt; （轨迹球事件） --pct-nav &lt;percent&gt;（导航事件 up/down/left/right） --pct-majornav &lt;percent&gt; (主要导航事件 back key 、 menu key) --pct-syskeys &lt;percent&gt; (系统按键事件 Home 、Back 、startCall 、 endCall 、 volumeControl) --pct-appswitch &lt;percent&gt; （activity之间的切换） --pct-anyevent &lt;percent&gt;（任意事件） 约束选项： -p：指定有效的package（如不指定，则对系统中所有package有效），一个-p 对应一个有效package， 如： -p com.ckt -p com.ckt.asura； -c：activity必须至少包含一个指定的category，才能被启动，否则启动不了； 调试选项： –dbg-no-events：初始化启动的activity，但是不产生任何事件。为了得到最佳结果，把它与-v、一个或几个包约 束、以及一个保持Monkey运行30秒或更长时间的非零值联合起来，从而提供一个环境，可以监视应用程序所调用的包之间的转换 --hprof：指定该项后在事件序列发送前后会立即生成分析报告 —— 一般建议指定该项。 --ignore-crashes：忽略崩溃 --ignore-timeouts：忽略超时 --ignore-security-exceptions：忽略安全异常 --kill-process-after-error：发生错误后直接杀掉进程 --monitor-native-crashes：跟踪本地方法的崩溃问题 --wait-dbg：直到连接了调试器才执行monkey测试。 ##四、栗子： adb shell monkey -p com.ssjjsy.sdk.hk.demo -s 100 --throttle 10 --ignore-crashes --ignore-timeouts --monitor-native-crashes --pct-appswitch 30 --pct-majornav 20 --pct-nav 20 --pct-touch 20 --pct-motion 10 -v -v -v 10000 &gt; E:\Git\monkey_log.txt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化（一）之常用工具]]></title>
      <url>%2F2017%2F04%2F09%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[Android性能优化相关的开发工具有很多很多种，这里对如下六个工具做个简单的使用介绍，主要有： Android开发者选项 分析具体耗时的Trace view 布局复杂度工具Hierarchy View 应用启动时间 Memory、CPU、Network分析 静态代码检查工具Lint 程序稳定性monkey ###一、Android开发者选项 Andorid手机自带的开发者选项： Take bug report（进行漏洞报告）: 点击这个选项会获取当前设备的log信息文件，打包并准备发送我们想要发送的人。这会花费1、2分钟，然后会看到一个准备好的提示信息，然后可以点击发送。 Desktop backup password（桌面备份密码）：可以使用adb备份和存储app和他们的关联数据到你的电脑。这个选项强制需要一个密码备份和存储。 Stay awake（保持唤醒）：选中这个复选框会强制屏幕唤醒，只要连接上usb线或者充电的时候都会不进入休眠，当需要调试的时候不用老是去解锁了，相当方便。 Select runtime（选择运行时）：你可以选择Dalvik或者ART。ART仍然是实验性的，直到Android L才最终release。 Enable Bluetooth HCI snoop log（蓝牙HCI搜索日志）：有时，开发者需要获取和分析蓝牙的HCI包，使能这个会在设备storage（路径为：/sdcard/btsnoop_hco.log）中保存包的信息。接着你可以使用类似wireshark等软件分析。 Process stats（程序状态）：你需要知道的所有运行在手机上的程序的任何信息。包括了ram使用量，运行时间等。 USB debugging（USB调试）：USB调试时使用，使用DDMS和ADB命令的时候也需要这个使能，不勾选这个就不能调试我们的应用了。 Revoke USB debugging authorizations（撤回USB除错授权）：当第一次USB线连接电脑的时候，需要认证并且建立密钥，这个操作删除这个认证，强制重新来一遍。 Power menu bug reports（电源菜单中包括漏洞报告）：在电源菜单中包括用于进行漏洞报告的选项。 Allow mock locations（允许虚拟位置）：允许手动写入位置信息，对于需要模拟位置的应用来说十分方便，可以干一些坏事，你懂得。 Select debug app（选择待调试的应用程序）：这个设置让你选择一个待调试的应用。 Wait for debugger（等待调试程序）：等待调试程序 Show touches（显示触摸位置）：显示触摸的位置，一般是一个小圈圈。 Pointer location（显示指针位置）：显示出当前位置的坐标。 Show surface updates（显示屏幕更新）：屏幕更新时会闪烁。 Show layout bounds（显示布局边界）：显示剪切边界、边缘。 Force RTL layout direction（强制RTL布局）：界面布局从右至左。 Window animation scale（窗口动画比例）：窗口动画的比例，数字越小，速度越快。 Transition animation scale（过渡动画比例）：过渡动画的比例，同上。 Simulate secondary displays（模拟二级显示）：允许开发者模拟不同尺寸的表现。 Force GPU rendering（强制GPU渲染）：强制应用使用硬件2D渲染除非应用本身不需要。 Show GPU view updates（显示GPU视图更新）：任何用硬件GPU来绘制视图的会有红色的覆盖层。 Show hardware layer updates（显示硬件层更新）：这个设置会告诉你什么时候硬件层在更新。 Debug GPU overdraw（调试GPU过度渲染）：过度渲染发生在任何时候当应用请求系统绘制一些视图在其他视图之上的时候。 Force 4x MSAA（启动4x MSAA）：这个设置强制多重采样抗锯齿。MSAA就是寻找出物体边缘部分的像素，然后再把画缩放到当前的显示器上。会降低性能提升视觉的美感。 Strict mode enabled（严格模式）：应用程序在主线程上执行长时间操作屏幕会闪烁。 Show CPU usage（显示CPU使用情况）：在屏幕右上角显示当前CPU的信息。 Profile GPU rendering（GPU显示配置文件）：这个设置可以在屏幕上显示也可以写入到文件中。 Enable OpenGL traces（启动OpenGL跟踪）：这个设置是观察OpenGL的错误，并把log保存到文件中。 Don’t keep activities（不保留活动）：用户离开后立即清理每个活动。 Background process limit（限制后台进程）：允许当前后台运行多少个进程的一个选择。 Show all ANRs（显示全部ANR）：当应用有bug的时候回显示应用无响应对话框。 ###二、应用具体耗时工具Trace view Trace view用于查找程序运行时具体耗时在哪，它显示两个面板，一个是Timeline面板，描述每一个线程和方法启动和结束的时间。另一个是Profile面板，提供一个所有方法内部发生了什么的概要。 先新建工程PerformanceTool，然后新建布局main_activity_layout.xml，一个按钮用来加载一个网页；另一个页面就是一个webview。然后编写代码，首先是MainActivity.java: public class MainActivity extends AppCompatActivity { private Button mBtnOpenWevView = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); } private void initView() { mBtnOpenWevView = (Button) findViewById(R.id.button); mBtnOpenWevView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this , WebViewActivity.class); startActivity(intent); } }); } } 接着是WebviewActivity.java： public class WebViewActivity extends AppCompatActivity { private WebView mWebView = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_webview); //Debug.startMethodTracing(&quot;perform&quot;); initView(); //Debug.stopMethodTracing(); } private void initView() { mWebView = (WebView) findViewById(R.id.mWebView); mWebView.loadUrl(&quot;http://www.baidu.com&quot;); mWebView.setWebViewClient(new WebViewClient(){ @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { view.loadUrl(url); return true; } }); } @Override protected void onDestroy() { super.onDestroy(); mWebView = null; } } ####view形式 traceview有两种使用方法，一种是直接通过DDMS工具来start和stop trace，使用方法如下：接着运行程序，成功运行后 点击菜单栏的Tools -&gt; Android -&gt; Android Device Monitor ： 进入Monitor之后，点击DDMS,这个时候在monitor的左边面板会出现当前设备上的包名列表 点击对应要trace的包名，然后点击Stop左边的有个小红点的按钮点击ok之后便开始执行trace了，这个时候再点击那个app里面的加载网页的按钮，加载完后，再次点击那个STOP左边那个变成小黑点的按钮。 接着便trace完成了，就可以查看如下两个面板了。上图就是Timeline面板，左边就是每行都是显示一个线程，右边对应它的时间线。可以看出来主要就是main线程在做事情。上图就是Profile面板，首先是左边的name，比如序号为14，这里展开有Parents和Children，其中Parents就是调用该方法的方法，这里onCreate在performCreate中被调用，Children就是该方法内部调用的方法，这里调用了loadUrl。与项目中的真实的代码完全相符。接着看下右边一排的Incl Cpu Time、Excl Cpu Time、Incl Real Time、Excl Real Time、Call+Recur Calls/Total、Cpu Time/Call、Real Time/Call。 Incl Cpu Time：某方法占用CPU的时间，包含内部调用其他方法占用CPU的时间。 Excl Cpu Time：某方法占用CPU的时间，不包含内部调用其他方法所占用的CPU时间。 Incl Real Time：某方法运行的真实的时间（单位ms），包含内部调用其他方法所占用的真实时间。 Excl Real Time：某方法运行的真实的时间（单位ms），不包含内部调用其他方法所占用的真实时间。 Call+Recur Calls/Total：某方法被调用的次数以及递归调用占总调用次数的百分比。 Cpu Time/Call：某方法占用CPU的时间和次数的比例。 Cpu Time/Call：某方法占用CPI真实时间和调用次数的比例。 ####代码形式 另一种是通过注入代码来实现： 在WebviewActivity的onCreate代码中加入两行代码如下： @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_webview); Debug.startMethodTracing(&quot;perform&quot;); initView(); Debug.stopMethodTracing(); } 别忘了加上SD卡的读写权限，然后运行app，点击加载网页按钮，就会在/sdcard目录下生产perform.trace文件，通过adb pull可以把文件导出来。 adb pull /sdcard/perform.trace Downloads/ 这里导出到了Downloads目录下，然后通过AndroidMonitor的file-&gt;open file选择这个文件打开：然后就可以查看分析了。通过代码的好处就是比较精确的得到我们想要测试的，不过代价就是要写代码编译，导出来，步骤相对来说比较繁琐。而直接使用工具的话只是一个大概的范围，但是方便快捷。可以视情况使用其中之一。 ###三、布局复杂度工具Hierarchy View Hierarchy View主要是检测布局复杂度，各视图的布局耗时情况的一个工具，它需要在模拟器上进行，真机好像也有方法解决，不过很懒没去折腾，主要还是学习工具为主嘛。 点击菜单Tools -&gt; Android -&gt; Android Device Monitor： 然后进入到Android Device Monitor，选中Hierarchy View选中后会出现层级树然后我们点击那个加载网页的button，可以看到对应的加载耗时，分别有Measure，Layout和Draw的耗时。 我们可以根据其耗时来优化我们界面。 ###四、应用启动时间 一般我们都会比较关注一个app启动的时间，如果启动太慢了，用户可能就不想玩了，这里有个方法可以测试应用启动的时间：命令行如下： adb shell am start -W packagename/activity 这里举个例子，比如说是上述项目中的PerformaceDemo app，那么首先打开终端，连接上usb线，然后终端输入: adb shell am start -W com.performance.demo/.MainActivity 等待会儿，app会启动，并且输出如下所示信息： Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER]cmp=com.performance.demo/.MainActivity } Status: ok Activity: com.performance.demo/.MainActivity ThisTime: 791 TotalTime: 791 WaitTime: 808 Complete 如上所示可以看出用时791ms。 ###五、Memory、CPU、Network 很多时候我们需要了解app的内存使用情况，CPU占用怎样，网络速度如何。为了提高性能，我们总是想把内存减少到最小，CPU占用率近可能小，网络情况适宜。当然这些可以用命令行实现，毕竟androd基于linux操作系统的，但是那样显得很麻烦又不是很直观，很庆幸Android Studio自带了功能。Android Studio的Android Monitor里面有logcat和Monitors，选中monitors就有对于Memory，CPU和Network的展示。如下图所示： 这里展示了Memory的使用量，CPU的占用量，以及网络的速度。上图就是点击了加载网页时候的一个分布情况。它可以帮我们查看并优化我们的程序，从而显得非常的直观。 ###六、 静态代码检查工具Lint Lint主要是提供一套静态代码分析的工具，它可以帮助我们检查项目中存在的问题，让我们更有规范性的开发App。运行菜单的analyze-&gt;Inspect Code 稍息片刻系统就会分析完成，如下所示： Lint分很多子项。Internationalization国际化问题，硬编码的文字都是需要添加进@string资源，Security安全性问题，Usability可用性问题，未使用到资源、资源缺少的问题等等，具体可以根据分析后的结果来一步步改善。 ###七、程序稳定性：monkey 通过monkey对程序在提交测试前做自测，可以检测出明显的导致程序不稳定的问题，执行monkey只需要一行命令，提交测试前跑一次可以避免应用刚提交就被打回的问题。 adb shell monkey -p com.performance.demo -v 500 -p表示包名，-v表示反馈级别 500就是500个伪随机事件若在压力测试中程序崩溃或者接收到任何失控异常，就会自动停止。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java服务端开发环境搭建]]></title>
      <url>%2F2017%2F03%2F21%2FJava%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[0 JDK下载安装 进入源码存放目录（eg：cd /data/src） wget下载jdk，由于wget不支持重定向，所以需要添加header（eg:wget –no-cookie –header “Cookie: oraclelicense=accept-securebackup-cookie” jdk） mv 下载的jdk压缩包到 安装目录（eg：mv jdk.tar.gz /usr/local/java） 解压安装包(eg:tar zxvf jdk.tar.gz) 运行 java -version 验证是否安装成功 1 配置环境变量这里介绍两种常用的环境变量配置方法： 修改/etc/profile文件:如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。 打开环境变量配置文件（eg:vi /etc/profile） 在文件尾追加 JAVA_HOME=/usr/local/java/jdk1.8.0_121 CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME export CLASSPATH 使用source命令启用配置（eg:source /etc/profile） 修改.bashrc文件：这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别。 打开用户目录的.bashrc文件（eg:vi ~/.bashrc） 在文件尾追加 JAVA_HOME=/usr/local/java/jdk1.8.0_121 CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME export CLASSPATH 退出重新登录 2 环境测试 在任意目录，通常在/data/tmp目录新建一个java文件（eg:Demo.java） 编译代码，javac Demo.java 运行代码，java Demo 3 常见问题“Error: Could not find or load main class” 如果java代码里面没有设置package，则是环境变量配置有误； 如果java代码里面有设置package，则需要构建和包名一致的路径，eg:package com.cjh.demo,则需要构建com/cjh/demo目录，并把编译的class文件放到该目录，然后回到和com平级的目录里面运行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我和我的博客]]></title>
      <url>%2F2017%2F03%2F03%2F%E6%88%91%E5%92%8C%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[工作已经快两年了，写了很多代码，也看了很多博客，慢慢的也有了自己的感悟，所以就有了这个博客。 GitHub. 缘由我认为有两点 记录与升华。通过写博客，我们可以记录工作中的思考、生活中的点滴，技术成长的同时，也装点了我们的回忆。 分享与提升。通过写博客，促使我们去专研问题并与人分享，同时通过他人的交流反馈来改善自我、提升自我。 另一份简历。博客也是简历之一，通过博客，可以更好的向他人展示自我。这也是非常有趣的事O(∩_∩)O~~ 风格简单，直接，文艺]]></content>
    </entry>

    
  
  
</search>
